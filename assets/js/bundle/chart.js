/* *!
 * Chart.js v2.9.3
 * https://www.chartjs.org
 * (c) 2019 Colaboradores do Chart.js
 * Lançado sob a licença MIT
 * /
! function (t, e) {"objeto" == tipo de exportação && "indefinido"! = tipo de módulo? module.exports = e (função () {tente {retornar exigir ("momento")} capturar (t) {}} ()): "função" == tipo de definição && define.amd? define (["exigir"], (função (t) {retornar e (função () {tentar {retornar t ("momento")} capturar (t) { }} ())})) :( t = t || self) .Chart = e (t.moment)} (this, (function (t) {"use strict"; t = t && t.hasOwnProperty ("default" )? t.default: t; var e = {aliceblue: [240.248.255], antiquewhite: [250.235.215], aqua: [0.255.255], aquamarine: [127.255.212], azure: [240.255.255], bege: [245.245.220], bisque: [255228196], preto [0,0,0], blanchedalmond: [255235205], azul [0,0,255], azul violeta: [138,43,226], Brown [165,42,42] burlywood: [222184135 ] cadetblue: [95158160], chartreuse: [127,255,0], chocolate [210,105,30], coral [255,127,80]cornflowerblue: [100149237], cornsilk: [255248220], carmesim [220,20,60], ciano [0255255], azul escuro: [0,0,139], Darkcyan: [0139139], Darkgoldenrod: [184,134,11] cinza escuro: [169169169], verde escuro: [0,100,0], cinza escuro: [169169169], escuro cáqui: [189183107], escuro magenta: [139,0,139], no fundo verde oliva: [85,107,47] DarkOrange: [255,140,0] DarkOrchid: [153,50,204] darkred: [139,0,0], salmão escuro: [233150122], DarkSeaGreen: [143188143], darkslateblue: [72,61,139], darkslategray: [47,79,79], cinza escuro tarde: [47,79,79], darkturquoise [0206209], violeta escuro [148,0,211] deeppink: [255,20,147] deepskyblue [0191255], dimgray: [105105105], dimgrey: [105105105], DodgerBlue: [30144255], firebrick: [178,34,34] floralwhite: [255250240], verde floresta: [34,139,34], fúcsia: [255,0,255] Gainsb: [220220220], fantasma branco: [248248255], ouro: [255,215,0], goldenrod [218,165,32], cinza [128128128], verde:[0,128,0], greenyellow: [173,255,47], cinzento [128128128], honeydew: [240255240], hotpink [255105180], Indianred: [205,92,92] anil [75,0,130] marfim: [255255240], caqui: [240230140], lavanda: [230230250], lavenderblush: [255240245], lawngreen: [124,252,0], limão chiffon: [255250205], luz azul: [173216230], coral claro: [240128128], lightcyan: [224255255], LightGoldenRodYellow: [250250210], cinza claro: [211211211], verde claro: [144238144], cinza claro: [211211211], luz rosa [255182193], salmão luz: [255160122], lightseagreen: [32178170], Lightskyblue: [135206250], luz do fim cinza: [119136153], luz do fim cinza: [119136153], a luz azul aço [176196222], amarelo claro: [255255224], cal [0,255,0], limegreen: [50,205,50], linho: [250240230] magenta: [255,0,255], marrom: [128,0,0], água marinha forma: [102205170], azul médio: [0,0,205], orquídea forma: [186,85,211]roxo médio: [147112219], mediumseagreen: [60179113], semitardias azul: [123104238], verde primavera meio: [0.250.154], mediumturquoise: [72209204], mediumvioletred: [199,21,133] meia-noite azul: [25,25,112], mintcream: [245255250 ] MistyRose: [255228225], mocassim: [255228181], Navajo branco: [255222173] marinha [0,0,128] oldlace: [253245230], azeitona [128,128,0], olivedrab: [107,142,35] laranja: [255,165,0] orangered: [255,69,0], orquídea: [218112214], PaleGoldenrod: [238232170], palegreen: [152251152], PaleTurquoise: [175238238], palevioletred: [219112147], papayawhip: [255239213], Peachpuff: [255218185], peru: [205,133,63], rosa [255192203], ameixa: [221160221], azul de pó: [176224230], roxo [128,0,128], Rebecca roxo: [102,51,153 ] red [255,0,0], rosybrown: [188143143], azul real: [65105225], castanho sela [139,69,19] salmão [250128114], arenoso castanho: [244,164,96] seagreen:[46,139,87], concha [255245238], Sienna: [160,82,45], prata [192192192], skyblue [135206235], ardósia azul: [106,90,205], ardósia cinza: [112128144], ardósia cinza: [112128144] neve: [255250250], verde primavera [0.255.127], azul aço [70130180], tan [210180140], cerceta [0.128.128], cardo: [216191216], tomate: [255,99,71] turquesa: [64224208], violeta: [238130238], trigo [245222179], branco: [255255255], fumo branco: [245245245], amarelo: [255,255,0], verde amarelo [154,205,50]}, n = função (t, e) {return t (e = {exporta: {}}, e.exporta), e.exporta} ((função (t) {var n = {}; para (var i em e) e.hasOwnProperty (i) && (n [e [i]] = i); var a = t.exports = {rgb: {canais: 3, marcadores: "rgb"}, hsl: {canais: 3, marcadores: "hsl" } HSV: {canais: 3, rótulos "HSV"}, HWB: {canais: 3, rótulos: "HWB"}, CMYK: {canais: 4, etiquetas "CMYK"}, xyz: {canais: 3 , rótulos "xyz "}, laboratório: {canais: 3, rótulos:" laboratório "}, l: {canais: 3, rótulos:" l "}, Hex: {canais 1, rótulos: [" hex "]}, palavra-chave: {canais: 1, rótulos: [ "palavra-chave"]}, ansi16: {canais 1, rótulos: [ "ansi16"]}, ansi256: {canais 1, rótulos: [ "ansi256"]}, o hCG: {canais 3, rótulos: [ "h", "c", "g"]}, maçã: {canais: 3, rótulos: [ "R16", "G16", "B16"]}, cinzento: {canais: 1 , labels: ["grey"]}}; for (var r em a) if (a.hasOwnProperty (r)) {if (! ("canais" em um [r])) gera novo erro ("propriedade de canais ausentes : "+ r); if (! (" labels "em um [r])) lança novo erro (" propriedade de falta de rótulos de canal: "+ r); if (a [r] .labels.length! == a [ r] .channels) lança um novo erro ("canal e etiqueta não correspondem:" + r); var o = a [r] .channels, s = a [r] .labels; exclua a [r] .channels,excluir um rótulo [r]., Object.defineProperty (a [r], "channels", {value: o}), Object.defineProperty (a [r], "labels", {value: s})} a. rgb.hsl = função (t) {var e, n, i = t [0] / 255, a = t [1] / 255, r = t [2] /255,o=Math.min (i, a (r), s = Math.max (i, a, r), l = so; return s === o? e = 0: i === s? e = (ar) / l: a === s e = 2 + (ri) / l: r === s && (e = 4 + (IA) / l) (e = Math.min (60 * e, 360)) <0 && (e + = 360) , n = (a + d) / 2 [e, 100 * (s === o 0 :? n <= 5 l / (s + O):.? l / (2-lo)), 100 * n]}, a.rgb.hsv = função (t) {var e, n, i, a, r, o = t [0] / 255, s = t [1] / 255, l = t [2] /255,u=Math.max(o,s,l),d=u-Math.min(o,s,l),h=function(t){return(ut)/6/d+.5}; Retorna 0 === d? a = r = 0: (r = d / u, e = h (o), n = h (s), i = h (l), o === u? a = em : s === u a = 1/3 + EI: l u === && (a = 2/3 + NE), uma <0 = a + 1: a> 1 && (a- = 1)), [ 360 * a, 100 * r, 100 * u]}, a.rgb.hwb = função (t) {var e = t [0], n = t [1], i = t [2]; return [a .rgb.hsl (t) [0] 100 * (* 1/255 Math.min (s, Math.min (n, i))), 100 * (i = 1-1 / 255 * Math.max (e, Math.max (n, i)))]}, a.rgb.cmyk = função (t) {var e, n = t [0] / 255, i = t [1] / 255, a = t [2] / 255; retorno [100 * ((1-N- (e = Math.min (1-N, I-1, 1-a))) / (1-e) || 0), 100 * ((1-ie) / (1-e) || 0), 100 * ((1-AE) / (1-e) || 0), 100 * e]}, a.rgb.keyword = função (t) {var i = n [t]; se (i) retornar i; var a, r, o, s = 1/0; for (var l em e) if (e.hasOwnProperty (l)) { var u = e [l], d = (r = t, o = u, Math.pow (r [0] -o [0], 2) + Math.pow (r [1] -o [1], 2) + Math.pow (r [2] -o [2], 2)); d <s && (s = d, a = l)} retorna a}, a.keyword.rgb = function (t) {return e [t]}, a.rgb.xyz = função (t) {var e = t [0] / 255, n = t [1] / 255, i = t [2] / 255; return [100 * ( 0,4124 * (? e = e> 0,04045 Math.pow ((e + 0,055) /1.055,2.4): e / 12,92) + * 3576 (n = n> 0,04045 Math.pow ((n + 0,055.? ) /1.055,2.4): N / 12,92) + 1,805 * (i = i> 0,04045 Math.pow ((i + 0,055) /1.055,2.4) i / 12,92)), 100 * (2126 *.?. e + .7152 * n + .0722 * i), 100 * (. 0193 * e + .1192 * n + .9505 * i)]}, a.rgb.lab = function (t) {var e = a.rgb.xyz ( t), n = e [0], i = e [1], r = e [2]; retorno i / = 100, r / = 108..? 883, N = (N / = 95047)> 008 856 Math.pow (s, 1/3): 7,787 * n + 16/116, [116 * i (i => 0,008856 Math.pow (i ,? 1/3): 7787 * i + 16/116) * -16,500 (ni), 200 * (i- (r = r> 0,008856 Math.pow (R, 1/3?): 7,787 * r + 16 / 116))]}, a.hsl.rgb = função (t) {var e, n, i, a, r, o = t [0] / 360, s = t [1] / 100, l = t [ 2] / 100;? se (0 === s) de retorno [R = 255 * G, R, R] e = 2 * l (n = l <l 0,5 * (1 + s) L + sl * s), a = [0,0,0]; para (var u = 0; u <3; u ++) (i = o + 1/3 * - (u-1)) <0 && i ++, i> 1 &&i ? -, r = 6 * i <1 e + 6 * (NE) * i: 2 * i <n 1: 3 * i <2 e + (NE) * (2/3-i) * 6 :? e, a [u] = 255 * r; retorna a}, a.hsl.hsv = função (t) {var e = t [0], n = t [1] / 100, i = t [2] / 100, a = n, r = Math.max (i, .01); return n * = (i * = 2) <= 1? I: 2-i, a * = r <= 1? R: 2- r, [e, 100 * (0 === i 2 * a / (r + a): 2 * n / (I + N)), 100 * ((i + n) / 2)]}, uma .hsv.rgb = função (t) {var e = t [0] / 60, n = t [1] / 100, i = t [2] / 100,a=Math.floor (e)% 6, r = e-Math.floor (e), o = 255 * i * (1-n), s = 255 * i * (n * 1-r), l = 255 * i * (1-N * (1- r)); switch (i * = 255, a) {caso 0: retornar [i, l, o]; caso 1: retornar [s,i, o]; caso 2: retornar [o, i, l]; caso 3: retornar [o, s, i]; caso 4: retornar [l, o, i]; caso 5: retornar [i, o, s]}}, a.hsv.hsl = função (t) {var e, n, i, a = t [0], r = t [1] / 100, o = t [2] / 100, s = Math.max (o, .01); return i = (2-r) * o, n = r * s, [a, 100 * (n = (n / = (e = (2-r) * s)) <= 1? E: 2-e) || 0), 100 * (i / = 2)]}, a.hwb.rgb = função (t) {var e, n, i, a, r, o, s, L = T [0] / 360, u = t [1] / 100, d = t [2] / 100, h = u + d; interruptor (h> 1 && (u / = h, d / = h ), I = 6 * l- (e = Math.floor (6 * l)), 0! = (1-e) && (i = 1-i), a = u + i * ((n = 1-d) -u), e) {padrão: caso 6: caso 0: r = n, o = a, s = u; pausa; caso 1: r = a, o = n, s = u; pausa; caso 2: r = u, o = n, s = a; intervalo; caso 3: r = u, o = a, s = n; intervalo; caso 4: r = a, o = u, s = n; intervalo; caso 5: r = n, o = u, s = a} retornar [255 * r, 255 * o, 255 * s]}, a.cmyk.rgb = função (t) {var e = t [0] / 100, n t = [1] / 100, i = t [2] / 100, a = t [3] / 100; retorno [255 * (1-Math.min (1, e * (1-a) + a)) , 255 * (1-Math.min (1, n * (1-a) + a)), 255 * (1-Math.min (1, i * (1-a) + a))]}, uma .xyz.rgb = função (t) {var e, n, i, a = t [0] / 100, r = t [1] / 100,o = t [2] / 100; retorno n = - 9689 * a + 1,8758 * r + 0,0415 * o, i = 0,0557 * a + - 204 * r + 1,057 * o, e = (e = 3,2406 * a + -1,5372 * r + - 4986 * o)> 0.031.308 1.055 * Math.pow (s, 1 / 2,4) - 055:? ... 12,92 * e, n = n> 0,0031308 1.055 * Math.pow (n, 1 /2.4)-.055:12.92*n,i=i>.0031308?1.055*Math.pow(i,1/2.4)-.055:12.92*i,[255*(e=Math.min(Math. max (0, e), 1)), 255 * (n = Math.min (Math.max (0, N), 1)), 255 * (i = Math.min (Math.max (0, i) , 1))]}, a.xyz.lab = função (t) {var e = t [0], n = t [1], i = t [2]; retorno n / = 100, i / = 108.883 , e = (e / = 95047)> 008 856 Math.pow (s, 1/3).? * (n = n> 0,008856 Math.pow (n 7787 * e + 16/116, [116, 1? /3):7.787*n+16/116)-16,500*(en),200*(n-(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116 ))]}, a.lab.xyz = function (t) {var e, n, i, a = t [0]; e = t [1] / 500 + (n = (a + 16) / 116) , i = nt [2] / 200; var r = Math.pow (n, 3), o = Math.pow (e, 3), s = Math.pow (i, 3); retorno n = r>. 008856 r (n-16/116) /7.787,e=o> 0,008856 o:? (P-16/116) /7.787,i=s> 0,008856 s: (i-16/116) / 7787,[e * = 95.047, n * = 100, i * = 108.883]}, a.lab.lch = função (t) {var e, n = t [0], i = t [1], a = t [ 2]; retorno (e = 360 * math.atan2 (a, i) /2/Math.PI) <0 && (e + = 360), [N, Math.sqrt (i * i + a * a), e] }, a.lch.lab = função (t) {var e, n = t [0], i = t [1]; retorno e = t [2] /360*2*Math.PI, [n, i * Math.cos (e), i * Math.sin (e)]}, a.rgb.ansi16 = função (t) {var e = t [0], n = t [1], i = t [2 ], r = 1 nos argumentos? argumentos [1]: a.rgb.hsv (t) [2]; if (0 === (r = Math.round (r / 50))) retorna 30; var o = 30+ (Math.round (i / 255) << 2 | Math.round (n / 255) << 1 | Math.round (e / 255)); return 2 === r && (o + = 60), o }, a.hsv.ansi16 = função (t) {retorna a.rgb.ansi16 (a.hsv.rgb (t), t [2])}, a.rgb.ansi256 = função (t) {var e = t [0], n = t [1], i = t [2]; return e === n && n === i? e <8? 16: e> 248? 231: Math.round ((e-8 ) / 247 * 24) + 232: 16 + 36 * Math.round (e / 255 * 5) + 6 * Math.round (n / 255 * 5) + Math.round (i / 255 * 5)}, uma .ansi16.rgb = função (t) {var e = t% 10; se (0 === e || 7 === e) retornar t> 50 && (e + = 3,5), [e = e / 10,5 * 255, e, e]; var n = 0,5 * (1 + ~~ (t> 50)); return [(1 & e) * n * 255, ( e >> 1 & 1) * n * 255, (e >> 2 & 1) * n * 255]}, a.ansi256.rgb = função (t) {if (t> = 232) {var e = 10 * (t- 232) +8; return [e, e, e]} var n; return t- = 16, [Math.floor (t / 36) /5*255,Math.floor ((n = t% 36) / 6 ) / 5 * 255, n% 6/5 * 255]}, a.rgb.hex = função (t) {var e = (((255 & Math.round (t [0])) << 16) + (( 255 & Math.round (t [1])) << 8) + (255 & Math.round (t [2]))) toString (16) .toUpperCase () ;. retorno "000000" .substring (e.length) + e }, a.hex.rgb = função (t) {var e = t.toString (16) .match (/ [a-f0-9] {6} | [a-f0-9] {3} / i) ; if (! e) retorna [0,0,0]; var n = e [0]; 3 === e [0] .length && (n = n.split ("")). map ((function (t ) {return t + t})). join ("")); var i = parseInt (n, 16); return [i >> 16 & 255, i >> 8 & 255,255 & i]}, a.rgb.hcg = function (t) {var e, n = t [0] / 255, i = t [1] / 255, a = t [2] / 255, r = Matemática.(max. Math (max. n (i), a), o = Math.min (Math.min (n, i), a), s = ro; return e = s <= 0? 0: r === N (Ia) / s% 6 :? r === i 2+ (a) / s:? 4+ (ni) / s + 4, e / = 6, [360 * (e = 1%), 100 * s, 100 * (s <1? o / (1-s): 0)]}, a.hsl.hcg = função (t) {var e = t [1] / 100, n = t [2] /100,i=1,a=0;return(i=n<.5?2*e*n:2*e*(1-n))<1&&(a=(n-.5*i)/ (1-i)), [t [0], 100 * i, 100 * a]}, a.hsv.hcg = função (t) {var e = t [1] / 100, n = t [2] / 100, i = e * n, a = 0; retorna i <1 && (a = (ni) / (1-i)), [t [0], 100 * i, 100 * a]}, a.hcg .rgb = função (t) {var e = t [0] / 360, n = t [1] / 100, i = t [2] / 100; se (0 === n) retornar [255 * i, 255 * i, 255 * i]; var a, r = [0,0,0], o = e% 1 * 6, s = o% 1, l = 1-s; switch (Math.floor (o) ) {caso 0: r [0] = 1, r [1] = s, r [2] = 0; quebra; caso 1: r [0] = l, r [1] = 1, r [2] = 0; quebra; caso 2: r [0] = 0, r [1] = 1, r [2] = s; quebra; caso 3: r [0] = 0, r [1] = l, r [2 ] = 1; quebra; caso 4: r [0] = s, r [1] = 0, r [2] = 1; quebra; padrão: r [0] = 1, r [1] = 0, r [ 2] = l} retorna a = (1-n) * i, [255 * (n * r [0] + a), 255 * (n * r [1] + a), 255 * (n * r [ 2] + a)]}, a.hcg.hsv = função (t) {var e = t [1] / 100, n = e + t [2] / 100 * (1-e), i = 0; retorno n> 0 && (i = e / n), [t [0], 100 * i, 100 * n]}, a.hcg.hsl = função (t) {var e = t [1] / 100, n = t [2] / 100 * (1-e ) +. 5 * e, i = 0; return n> 0 && n <.5? I = e / (2 * n): n> =. 5 && n <1 && (i = e / (2 * (1-n)) ), [t [0], 100 * i, 100 * n]}, a.hcg.hwb = função (t) {var e = t [1] / 100, n = e + t [2] / 100 * (1-e); return [t [0], 100 * (ne), 100 * (1-n)]}, a.hwb.hcg = função (t) {var e = t [1] / 100, n = 1-t [2] / 100, i = ne, a = 0; retorno i <1 && (a = (ni) / (1-i)), [t [0], 100 * i, 100 * a ]}, a.apple.rgb = função (t) {return [t [0] / 65535 * 255, t [1] / 65535 * 255, t [2] / 65535 * 255]}, a.rgb.apple = função (t) {return [t [0] / 255 * 65535, t [1] / 255 * 65535, t [2] / 255 * 65535]}, a.gray.rgb = função (t) {return [ t [0] / 100 * 255, t [0] / 100 * 255, t [0] / 100 * 255]}, a.gray.hsl = a.gray.hsv = função (t) {return [0, 0, t [0]]}, a.gray.hwb = função (t) {return [0,100, t [0]]}, a.gray.cmyk = função (t) {return [0,0,0, t [0]]}, um.gray.lab = função (t) {retorna [t [0], 0,0]}, a.gray.hex = função (t) {var e = 255 e Math.round (t [0] / 100 * 255), n = ((e << 16) + (e << 8) + e) ​​.ToString (16) .toUpperCase (); retorno "000000" .substring (n.length) n +} = a.rgb.gray função (t) {return [(t [0] + t [1] + t [2]) / 3/255 * 100]}})); n.rgb, n.hsl, n.hsv, n.hwb (n.cmyk, n.xyz, n.lab, n.lch, n.hex, n.chave, n.ansi16, n.ansi256, n.hcg, n.apple, n.gray; function i (t) {var e = function () {para (var t = {}, e = Object.keys (n), i = comprimento e, a = 0; a <i; a ++) t [e [a]] = { distance: -1, parent: null}; return t} (), i = [t]; for (e [t] .distance = 0; i.length;) for (var a = i.pop (), r = Object.keys (n [a]), o = r.length, s = 0; s <o; s ++) {var l = r [s], u = e [l]; - 1 === u. distance && (u.distance = e [a] .distance + 1, u.parent = a, i.unshift (l))} return e} function a (t, e) {return function (n) {return e (t (n))}} função r (t, e) {para (var i = [e [t] .parente, t], r = n [e [t] .parente] [t], o = e [t ] .parent; e [O] .parent) i.unshift (e [o] .parent), r = a (n [e [o] .parent] [o], r), o = e [o] .parent; retorno r.conversion = i, r} var o = {}; Object.keys (n) .forEach ((função (t) {o [t] = {}, Object.defineProperty (O [T], "canais", {value: n [t]} .channels ), Object.defineProperty (o [t], "labels", {value: n [t] .labels}); var e = function (t) {for (var e = i (t), n = {}, a = Object.keys (e), o = a.length, s = 0; s <o; s ++) {var l = a [s]; null! == e [l] .parent && (n [l] = r (l, e))} return n} (t); Object.keys (e) .forEach ((function (n) {vari = e [n]; o [t] [n] = function (t) {var e = function (e) {if (null == e) return e; argumentos.length> 1 && (e = Array.prototype.slice.call (argumentos)); var n = t (e); if (" objeto "== tipo de n) para (vari = comprimento, a = 0; a <i; a ++) n [a] = Math.round (n [a]); return n}; return" conversion "in t && (e.conversion = t.conversion), e} (i), o [t] [n] .raw = função (t) {var e = função (e) {return null == e? e: (argumentos ,length> 1 && (e = Array.prototype.slice.call (argumentos)), t (e))}; retorna "conversão" em t && (e.conversion = t.conversion), e} (i)}))} )); var s = o, l = {aliceblue: [240,248,255], antiquewhite: [250,235,215], aqua: [0,255,255], água-marinha: [127,255,212], azure: [240,255,255], bege: [245,245,220], bisque: [ 255228196], preto [0,0,0], blanchedalmond: [255235205], azul [0,0,255], azul violeta: [138,43,226], Brown [165,42,42] burlywood: [222184135] , cadetblue: [95158160], chartreuse: [127,255,0], chocolate [210,105,30], coral [255,127,80] cornflowerblue: [100149237], cornsilk: [255248220], carmesim: [220,20, 60], ciano [0255255], azul escuro: [0,0,139], Darkcyan: [0139139], Darkgoldenrod: [184,134,11], cinzento escuro: [169169169], verde escuro: [0,100,0], cinzento escuro: [169169169] , cáqui escuro: [189183107], escuro magenta: [139,0,139], verde oliva profundo [85,107,47] DarkOrange: [255,140,0], escuro orquídea:[153,50,204] darkred: [139,0,0], escuro salmão: [233150122], DarkSeaGreen: [143188143], darkslateblue: [72,61,139], darkslategray: [47,79,79], escuro tardio cinzento: [47 , 79,79], darkturquoise [0206209], violeta escuro [148,0,211] deeppink: [255,20,147] deepskyblue [0191255], dimgray: [105105105], dimgrey: [105105105], DodgerBlue: [30144255 ], firebrick: [178,34,34] floralwhite: [255250240], verde floresta: [34,139,34], fúcsia: [255,0,255] Gainsb: [220220220], fantasma branco: [248248255], ouro [255,215 , 0], dourada [218,165,32], cinzento [128128128], verde [0,128,0], greenyellow: [173,255,47], cinzento [128128128], honeydew: [240255240], hotpink [255105180 ] Indianred: [205,92,92] anil [75,0,130] marfim [255255240], caqui [240230140], lavanda: [230230250], lavenderblush: [255240245], lawngreen: [124,252,0 ], limão chiffon [255250205], azul claro: [173216230], coral claro: [240128128]lightcyan: [224255255], LightGoldenRodYellow: [250250210], cinza claro: [211211211], verde claro: [144238144], cinza claro: [211211211], luz rosa [255182193], salmão luz: [255160122], lightseagreen: [32178170], Lightskyblue: [135206250], luz do fim cinza: [119136153], luz do fim cinza: [119136153], a luz azul aço [176196222], amarelo claro: [255255224], cal [0,255,0], limegreen: [50,205,50], linho: [250240230] magenta: [255,0,255] marrom: [128,0,0], ciano forma: [102205170], azul médio: [0,0,205], orquídea forma: [186,85,211], roxo médio: [147112219], mediumseagreen: [60179113 ], semitardias azul: [123104238], verde primavera meio: [0.250.154], mediumturquoise: [72209204], mediumvioletred: [199,21,133], azul da meia-noite: [25,25,112], mintcream: [245255250], MistyRose: [255228225], mocassim: [255228181], Navajo branco: [255222173] marinha [0,0,128] oldlace: [253245230], azeitona:[128,128,0], olivedrab: [107,142,35] laranja [255,165,0], orangered: [255,69,0], orquídea [218112214], PaleGoldenrod: [238232170], palegreen: [152251152] PaleTurquoise: [175238238], palevioletred: [219112147], papayawhip: [255239213], Peachpuff: [255218185], Peru [205,133,63] rosa: [255192203], ameixa: [221160221], azul de pó: [176224230], roxo: [128,0,128], Rebecca roxo: [102,51,153], vermelho: [255,0,0], rosybrown: [188143143], azul real [65105225], sela castanho: [139,69,19], salmão: [250128114], castanho areia: [244,164,96] seagreen: [46,139,87], concha [255245238], Sienna: [160,82,45], prata [192192192], azulceleste [135206235], azul de ardósia: [106,90,205], ardósia cinza: [112128144], ardósia cinza: [112128144] neve: [255250250], verde primavera [0.255.127], azul aço [70130180], tan [210180140], cerceta [0.128.128], cardo: [216191216], tomate: [255,99,71], turquesa: [64224208], violeta:[238130238], trigo [245222179], branco: [255255255], fumo branco: [245245245], amarelo: [255,255,0], verde amarelo [154,205,50]}, u = {getRgba: d, getHsla: h, getRgb: function (t) {var e = d (t); return e && e.slice (0.3)}, getHsl: function (t) {var e = h (t); return e && e.slice (0.3) }, getHwb: c, getAlpha: function (t) {var e = d (t); if (e) retorna e [3]; if (e = h (t)) retorna e [3]; if (e = c (t)) return e [3]}, hexString: function (t, e) {e = void 0! == e && 3 === t.length? e: t [3]; return "#" + v ( t [0]) + v (t [1]) + v (t [2]) + (e> = 0 && e <1 v (Math.round (255 * e)?): "")}, rgbString: function (t, e) {se (e <1 || t [3] && t [3] <1) retorna f (t, e); retorna "rgb (" + t [0] + "," + t [1 ] + "," + t [2] + ")"}, rgbaString: f, percentString: função (t, e) {se (e <1 || t [3] && t [3] <1) retorne g ( t, e); var n = Math.round (t [0] / 255 * 100), i = Math.round (t [1] / 255 * 100), a = Math.round (t [2] / 255 * 100); retornar "rgb (" + n + "%," + i + "%," + a + "%)"}}, percentaString: g, hslString: function (t, e) { if (e <1 || t [3] && t [3] <1) retorna p (t, e); retorna "hsl (" + t [0] + "," + t [1] + "%", " + t [2] + "%)"}, hslaString: p, hwbString: function (t, e) {void 0 === e && (e = void 0! == t [3]? t [3]: 1 ); return "hwb (" + t [0] + "," + t [1] + "%," + t [2] + "%" + (void 0! == e && 1! == e? ", "+ e:" ") +") "}, palavra-chave: function (t) {return b [t.slice (0,3)]}}; function d (t) {if (t) {var e = [ 0,0,0], n = 1, i = t.match (/ ^ # ([a-FA-F0-9] {3,4}) $ / I), a = ""; if (i) {a = (i = i [1]) [3]; para (var r = 0; r <comprimento; e ++) e [r] = parseInt (i [r] + i [r], 16); a && (n = Math.round (parseInt (a + a, 16) / 255 * 100) / 100)} else if (i = t.match (/ ^ # ([a-fA-F0-9] {6} ([a-FA-F0-9] {2})) $ / i)) {a = i [2], i = i [1] ;? para (r = 0;r <e.length; r ++) E [r] = parselnt (i.slice (2 * r * r 2 + 2), 16); um && (n = Math.round (parselnt (a, 16) / 255 * 100) / 100)} else if (i = t.match (/ ^ rgba? \ (\ S * ([+ -]? \ D +) \ s *, \ s *, \ s * ([+ -]? \ D +) \ s * \ s * - \ s * ([+] \ d +?)? (?: - [. \ d \] \ s * ([+] +) \ s *) \) $ / i) ) {for (r = 0; r <comprimento e; r ++) e [r] = parseInt (i [r + 1]); n = parseFloat (i [4])} else if (i = t.match ( /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s * \ s * ([+ -] [\ d \.] +?) \% \ s * (?: \ s * ([+ -] +) \ s * [\ d \.])? \) $ / i)) {para (r = 0; r <r e.length ++) e [r] = Math.round (2,55 * parseFloat (i [r + 1])); n = parseFloat (i [ 4])} else if (i = t.match (/ (\ w +) /)) {if ("transparent" == i [1]) retorna [0,0,0,0]; if (! (E = l [i [1]])) return} for (r = 0; r <comprimento e; r ++) e [r] = m (e [r], 0,255); return n = n || 0 == n? m (n, 0,1): 1, e [3] = n, e}} função h (t) {se (t) {var e = t.match (/ ^ hsla? \ (\ s * (? [+ -] \ d +) (:? °)? \ s * \ s * (? [+ -] [. \ d \] +)% \ s * \ s * ([+ -]? [\ d \.] +)% \ s * (?:, \ s * ([+ -]? [\ d \.] +) \ s *)? \) /); if (e) {var n parseFloat = s ([4]);? return [m (Parseint (S [1]), 0,360), m (parseFloat (e [2]), 0,100), m (parseFloat (s [3]), 0,100), m (isNaN (n) é de 1: n, 0,1)]}}} função c (t) {if (t) {var e = t.match (/ ^ hwb \ (\ s * ([+ -]? \ d +) (?: deg) ? \ s * \ s * ([+ -] [\ d \.] +?)% \ s * \ s * ([+ -] +? [\ d \.])% \ s * (? :, \ s * ([+ -]? [\ d \.] +) \ s *)? \) /); if (e) {var n = parseFloat (e [4]); return [m (parseInt (e [1]), 0,360), m (parseFloat (e [2]), 0,100), m (parseFloat (s [3]), 0,100), m (isNaN (n) 1:? N, 0,1 )]}}} função f (t, e) {retornar nulo 0 === e && (e = nulo 0! == t [3]? t [3]: 1), "rgba (" + t [0] + "," + t [1] + "," + t [2] + "," + e + ")"} função g (t, e) {return "rgba (" + Math.round (t [0] / 255 * 100) + "%", + Math.round (t [1] / 255 * 100) + "%," + Math.round (t [2] / 255 * 100) + "%," + ( e || t [3] || 1) + ")"} função p (t, e) {return void 0 === e && (e = void 0! == t [3]? t [3]: 1 ), "hsla (" + t [0] + "," + t [1] + "%", "+ t [2] + "%," + e + ")"} função m (t, e, n) {retorna Math.min (Math.min (e.max (e, t), n)) função v (t) {var e = t.toString (16) .toUpperCase (); return e.length <2? "0" + e: e} var b = {}; para (var x em l) b [l [x]] = x ; var y = função (t) {retorna t instância de y? ​​t: esta instância de y? ​​(this.valid =! 1, this.values ​​= {rgb: [0,0,0], hsl: [0,0, 0], hsv: [0,0,0], hwb: [0,0,0], cmyk: [0,0,0,0], alfa: 1}, nulo ("string" == tipo de t? (e = u.getRgba (t))? this.setValues ​​( "RGB", e) :( e = u.getHsla (t))? this.setValues ​​( "HSL" e) :( e = u.getHwb (t)) && this.setValues ​​("hwb", e): "objeto" == tipo de t && (void 0! == (e = t) .r || void 0! == e.red?this.setValues ​​( "rgb", e): void 0! == el || void 0! == e.lightness? this.setValues ​​("hsl", e): void 0! == ev || void 0! == e. valor? this.setValues ​​("hsv", e): void 0! == ew || void 0! == e.whiteness? this.setValues ​​("hwb", e): void 0 === ec && void 0 === e.cyan || this.setValues ​​("cmyk", e)))): novo y (t); var e}; y. prototype = {isValid: function () {retorna this.valid}, rgb: function () {retorna this.setSpace ("rgb", argumentos)}, hsl: function () {retorna this.setSpace ("hsl", argumentos )}, hsv: function () {retorna this.setSpace ("hsv", argumentos)}, hwb: function () {retorna this.setSpace ("hwb", argumentos)}, cmyk: function () {retorna isso. setSpace ("cmyk", argumentos)}, rgbArray: function () {retorna this.values.rgb}, hslArray: function () {retorna this.values.hsl}, hsvArray: function () {retorna this.values.hsv }, hwbArray: function () {var t = this.values; return 1! == t.alpha? t.hwb.concat ([t.alpha]): t.hwb}, cmykArray: function () {retorna isso .values.cmyk}, rgbaArray: function () {var t = this.values; retorna t.rgb.concat ([t.alpha])}, hslaArray:function () {var t = this.values; return t.hsl.concat ([t.alpha])}, alpha: function (t) {return void 0 === t? this.values.alpha: (this. setValues ​​("alpha", t), this)}, vermelho: function (t) {retorna this.setChannel ("rgb", 0, t)}, verde: function (t) {retorna this.setChannel ("rgb" , 1, t)}, azul: função (t) {retorna this.setChannel ("rgb", 2, t)}, matiz: função (t) {retorna t && (t = (t% = 360) <0? 360 + t: t), this.setChannel ("hsl", 0, t)}, saturação: função (t) {retorna this.setChannel ("hsl", 1, t)}, leveza: função (t) { retornar this.setChannel ("hsl", 2, t)}, saturaçãov: função (t) {retornar this.setChannel ("hsv", 1, t)}, brancura: função (t) {retornar this.setChannel (" hwb ", 1, t)}, escuridão: função (t) {retorna this.setChannel (" hwb ", 2, t)}, valor: função (t) {retorna this.setChannel (" hsv ", 2, t )}, ciano:função (t) {retorna this.setChannel ("cmyk", 0, t)}, magenta: função (t) {retorna this.setChannel ("cmyk", 1, t)}, amarelo: função (t) {return this.setChannel ("cmyk", 2, t)}, preto: function (t) {retorna this.setChannel ("cmyk", 3, t)}, hexString: function () {retorna u.hexString (this.values .rgb)}, rgbString: function () {retorna u.rgbString (this.values.rgb, this.values.alpha)}, rgbaString: function () {retorna u.rgbaString (this.values.rgb, this.values .alpha)}, percentString: function () {retorna u.percentString (this.values.rgb, this.values.alpha)}, hslString: function () {retorna u.hslString (this.values.hsl, this.values .alpha)}, hslaString: function () {retorna u.hslaString (this.values.hsl, this.values.alpha)}, hwbString: function () {retorna u.hwbString (this.values.hwb, this.values .alpha)}, palavra-chave: function () {return u.keyword (this.values.rgb, this.values.alpha)},rgbNumber: function () {var t = this.values.rgb; retorna t [0] << 16 | t [1] << 8 | t [2]}, luminosidade: function () {for (var t = this .values.rgb, e = [], n = 0; n <comprimento.n ++) {var i = t [n] / 255; e [n] = i <=. 03928? i / 12.92: Math. pow ((i + 0,055) / 1,055,2,4)} return.2126 * e [0] +. 7152 * e [1] +. 0722 * e [2]}, contraste: function (t) {var e = this .luminosidade (), n = t.luminosidade (); return e> n? (e + .05) / (n + .05) :( n + .05) / (e + .05)}, nível: function (t) { var e = this.contrast (t); return e> = 7.1? "AAA": e> = 4.5? "AA": ""}, dark: function () {var t = this.values.rgb; return ( 299 * t [0] + 587 * t [1] + 114 * t [2]) / 1E3 <128}, luz: função () {return this.dark ()}, negate: função () {para ( var t = [], e = 0; e <3; e ++) t [e] = 255-this.values.rgb [e]; retorna this.setValues ​​("rgb", t), isto}, lighten: function (t) {var e = this.values.hsl; return e [2] + = e [2] * t, this.setValues ​​("hsl", e), this}, escurece:function (t) {var e = this.values.hsl; return e [2] - = e [2] * t, this.setValues ​​("hsl", e), this}, sature: function (t) {var e = this.values.hsl; return e [1] + = e [1] * t, this.setValues ​​("hsl", e), this}, dessaturado: function (t) {var e = this.values. hsl; return e [1] - = e [1] * t, this.setValues ​​("hsl", e), this}, whiten: function (t) {var e = this.values.hwb; return e [1 ] + = e [1] * t, this.setValues ​​("hwb", e), this}, escurecido: function (t) {var e = this.values.hwb; return e [2] + = e [2 ] * t, this.setValues ​​("hwb", e), this}, escala de cinza: function () {var t = this.values.rgb, e = .3 * t [0] +. 59 * t [1] + .11 * t [2]; retorna this.setValues ​​("rgb", [e, e, e]), this}, mais claro: function (t) {var e = this.values.alpha; return this.setValues ("alpha", ee * t), isto}, opaquer: function (t) {var e = this.values.alpha; retorna this.setValues ​​("alpha", e + e * t), this}, gire: função (t) {var e = this.values.hsl, n = (e [0] + t)% 360; return e [0] = n <0? 360 + n: n, this.setValues ​​("hsl", e), this}, mix: function (t (a) (a) (b) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (a) (c) (c) * r == - 1? a: (a + r) / (1 + a * r)) + 1) / 2, s = 1-o; retorne this.rgb (o * this.red () + s * n.red () O * this.green () + s * n.green () O * this.blue) + s (n.blue * ()). alfa (this.alpha () * i + N .alpha () * (1-i))}, paraJSON: function () {retorna this.rgb ()}, clone: ​​function () {var t, e, n = new y, i = this.values, a = n.valores; para (var r in i) i.hasOwnProperty (r) && (t = i [r], "[matriz do objeto]" === (e = {}. toString.call (t))? a [r] = t.slice (0): "[número do objeto]" === e? a [r] = t: console.error ("valor inesperado da cor:", t)); return n}}, y.prototype.spaces = {RGB: [ "vermelho", "azul", "azul"], HSL: [ "matiz", "saturação", "luminosidade"], HSV: [ "matiz", "saturação", "valor"] HWB: [ "matiz", "brancura", "escuridão"], CMYK: [ "ciano", "Magenta", "amarelo", "preto"]} = {y.prototype.maxes rgb: [255255255 ], hsl: [360,100,100], hsv: [360,100,100], hwb: [360,100,100], cmyk: [100,100,100,100]}, y.prototype.getValues ​​= function (t) {for (var e = this.values, n = { }, i = 0; i <t.length; i ++) n [t.charAt (i)] = e [t] [i]; retorne 1! == e.alpha && (na = e.alpha), n} , y.prototype.setValues ​​= function (t, e) {var n, i, a = this.values, r = this.spaces, o = this.maxes, l = 1; if (this.valid =! 0, "alpha" === t) l = e; senão se (comprimento) a [t] = e.slice (0, comprimento), l = e [comprimento]; senão se (vazio 0! == e [t.charAt (0)]) {for (n = 0; n <T.Length; n ++) um [t] [n] = e [t.charAt (n)] = l eA} else if (void 0! == e [r [t] [0]]) {var u = r [t]; para (n = 0; n <comprimento de t; n ++) a [t] [n] = e [u [n]]; l = e.alpha} if (a.alpha = Math.max (0, Math.min (1, void 0 === l? a.alpha: l)), "alfa"=== t) retornar uma ;! Para (n = 0; n <T.Length; n ++) i = Math.max (0, Math.min (O [T] [n], de um [a] [n] )), a [t] [n] = Math.round (i); para (var d em r) d! == t && (a [d] = s [t] [d] (a [t])) ; return! 0}, y.prototype.setSpace = function (t, e) {var n = e [0]; return void 0 === n? this.getValues ​​(t) :( "number" == typeof n && (n = Array.prototype.slice.call (e)), this.setValues ​​(t, n), this)}, y.prototype.setChannel = função (t, e, n) {var i = this.values ​​[ t]; return void 0 === n? i [e]: n === i [e]? this: (i [e] = n, this.setValues ​​(t, i), this)}, "indefinido "! = typeof window && (window.Color = y); var _, k = y, w = {noop: function () {}, uid: (_ = 0, function () {return _ ++}), isNullOrUndef : function (t) {return null == t}, isArray: function (t) {if (Array.isArray && Array.isArray (t)) return! 0; var e = Object.prototype.toString.call (t); return "[objecto" === e.substr (0,7) && "matriz]" === e.substr (-6)}, IsObject:function (t) {return null! == t && "[object Object]" === Object.prototype.toString.call (t)}, isFinite: function (t) {return ("number" == typeof t || t instanceof Number) && isFinite (t)}, valueOrDefault: function (t, e) {return void 0 === t? e: t}, valueAtIndexOrDefault: function (t, e, n) {return w.valueOrDefault (w. isArray (t)? t [e]: t, n)}, retorno de chamada: função (t, e, n) {se (t && "função" == tipo de chamada)) retornar t.apply (n, e)} , each: function (t, e, n, i) {var a, r, o; if (w.isArray (t)) if (r = comprimento de t, i) para (a = r-1; a> = 0; a -) e.call (n, t [a], a); else for (a = 0; a <r; a ++) e.call (n, t [a], a); else if (w.isObject (t)) para (comprimento R = (o = Object.keys (t)), a = 0;. um <r; a ++) e.call (n, t [o [a]], o [a])}, arrayEquals: function (t, e) {var n, i, a, r; if (! t ||! e || t.length! == e.length) return! 1; for ( n = 0, i = comprimento; n <i; ++ n) if (a = t [n], r = e [n], uma instância de Array & & r instanceof Array) {if (! w.arrayEquals (a, r)) return! 1} else if (a! == r) return! 1; return! 0}, clone: ​​function (t) {if (w.isArray (t)) retorne t.map ( w.clone); if (w.isObject (t)) {for (var e = {}, n = Object.keys (t), i = comprimento n, a = 0; a <i; ++ a) e [n [a]] = w.clone (t [n [a]]); retorno e} retorno t}, _ fusão: função (t, e, n, i) {var a = e [t], r ? = n [t]; w.isObject (a) && w.isObject (r) w.merge (a, r, i): e [a] = w.clone (R)}, _ mergerIf: função (t, e , n) {var i = e [t], a = n [t]; w.isObject (i) && w.isObject (a)? w.mergeIf (i, a): e.hasOwnProperty (t) || ( e [t] = w.clone (a))}, mesclagem: function (t, e, n) {var i, a, r, o, s, l = w.isArray (e)? e: [e] , u = l.length; if (! w.isObject (t)) retorna t; para (i = (n = n || {}). fusão || w._merger, a = 0; a <u; + + a) se (e = l [a], w.isObject (e)) para o (s = 0, o = (r = Object.keys (e)) comprimento; s <o;. s ++) i ( r [s], t, e, n); retorna t}, mergeIf: function (t, e) {retorna w.merge (t, e, {fusão: w._mergerIf})}, estende: Object.assign | | function (t) {retorna w.merge (t, []. slice.call (argumentos,1), {fusão: função (t, e, n) {e [t] = n [t]}})}, herda: função (t) {var e = isto, n = t && t.hasOwnProperty ("construtor" )? t.constructor: function () {return e.apply (this, argumentos)}, i = function () {this.constructor = n}; return i.prototype = e.prototype, n.prototype = new i, n.extend = w.inherits, t && w.extend (n.prototype, t), n .__ super __ = e.prototype, n}, _ obsoleto: function (t, e, n, i) {void 0! == e && console. aviso (t + ': "' + n + '" está obsoleto. Use "' + i + '" em vez disso))}}, M = w; w.callCallback = w.callback, w.indexOf = function (t, e, n) {return Array.prototype.indexOf.call (t, e, n)}, w.getValueOrDefault = w.valueOrDefault, w.getValueAtIndexOrDefault = w.valueAtIndexOrDefault; var S = {linear: function (t) {return t} , facilidadeInQuad: função (t) {retornar t * t}, facilidadeOutQuad: função (t) {retorno-t * (t-2)}, facilidadeInOutQuad: função (t) {retorno (t / =. 5) <1? ,5 * t * t: -. 5 * (- t * (t-2) -1)}, comfortInCubic: function (t) {return t * t * t}, comfortOutCubic: function (t) {return (t - = 1) * t * t + 1}, easeInOutCubic: função (.? t) {return (t / = 5) <1 0,5 * t * t * t: 0,5 * ((t = 2) * t * t + 2)}, facilidadeInQuart: função (t) {retornar t * t * t * t}, facilidadeOutQuart: função (t) {retorno - ((t- = 1) * t * t * t-1) ?:} função easeInOutQuart (t) {return <1 0,5 * t * t * t * t (T / = 5.): -. 5 * ((t = 2) * t * t * t-2 )}, facilidadeInQuint: função (t) {retornar t * t * t * t * t}, facilidadeOutQuint: função (t) {retornar (t- = 1) * t * t * t * t + 1}, facilidadeInOutQuint: função (t) {return <1 0,5 * t * t * t * t * t (T / = 5.):? 0,5 ​​* ((t = 2) * t * t * t * t + 2) } facilidadeInSine: função (t) {retornar 1-Math.cos (t * (Math.PI / 2))}, facilidadeOutSine: função (t) {retornar Math.sin (t * (Math.PI / 2)) } facilidadeInOutSine: função (t) {retorno-.5 * (Math.cos (Math.PI * t) -1)}, facilidadeInExpo: função (t) {retorno 0 === t? 0: Math.pow ( 2.10 * (t-1))}, facilidadeOutExpo: função (t) {return 1 === t? 1: 1-Math.pow (2, -10 * t)}, facilidadeInOutExpo: função (t) { retornar 0 === t? 0:1 t === 1: (. T / = 5) <1 * 0,5 Math.pow (2,10 * (t-1)):. * 5 (2-Math.pow (2, -10? * - t))} comfortInCirc: function (t) {return t> = 1? t :-( Math.sqrt (1-t * t) -1)}, comfortOutCirc: function (t) {return Math. sqrt (1- (t = 1) * t)}, easeInOutCirc:. (.? t / = 5) função (t) {return <1-5 * (Math.sqrt (1-t * t) -1 ): 5 * (Math.sqrt (1- (t- = 2) * t) +1)}, facilidadeInElástico: função (t) {var e = 1,70158, n = 0, i = 1; return 0 == t = 0 :? 1 === t 1: (n || (n = 0,3), i <1 (i = 1, e = n / 4) :? e = n / (2 * Math.PI ) * math.asin (1 / i) - i * Math.pow (2,10 * (t = 1)) * Math.Sin ((tE) * (2 * Math.PI) / n))} , facilidadeOutElástico: função (t) {var e = 1,70158, n = 0, i = 1; retornar 0 === t? 0: 1 === t? 1: (n || (n = 0,3), i ? <1 (i = 1, e = n / 4): e = n / (2 * Math.PI) * math.asin (1 / i), i * Math.pow (2, -10 * t) * Math.sin ((te) * (2 * Math.PI) / n) +1)}, facilidadeInOutElástico: função (t) {var e = 1.70158, n = 0, i = 1; return 0 === t? 0: 2 == (t / = 5) 1 ?? (n || (n = 0,45), i <1 (i = 1, e = n / 4):. e = n / (2 * Math .PI) * math.asin (1 / i), t <1? i * Math.pow (2,10 * (t = 1)) * Math.sin ((TE) * (2 * Math.PI) / n) * - 5 :. i * Math.pow (2, -10 * (t = 1)) * Math.Sin ((TE) * (2 * Math.PI) / n) *. 5 + 1)}, facilidadeInBack: função (t) {var e = 1.70158; retornar t * t * ((e + 1) * te)}, facilidadeOutBack: função (t) {var e = 1.70158; return (t- = 1) * t * ((e + 1) * t + e) ​​+1}, facilidadeInOutBack: function (t) {var e = 1.70158; return (t / =. 5 ?) <1 t * t * ((1 + (a * = 1,525)) * te) * 5:. 0,5 * ((t = 2) * t * ((1 + (a * = 1,525)) * t + e) ​​+2)}, facilidadeInBounce: função (t) {retorno 1-S.easeOutBounce (1-t)}, facilidadeOutBounce: função (t) {retorno t <1 / 2,75? 7,5625 * t * t: t <2 / 2,75 7,5625 * (t = 1,5 / 2,75) * t + 0,75: t <2,5 / 2,75 7,5625 * (t = 2,25 / 2,75) * t + 0,9375: 7,5625 * (t = 2,625 / 2,75) * t + 0,984375}, comfortInOutBounce: function (t) {return t <0,5; 0,5 * S.easeInBounce (2 * t):. 5 * S.easeOutBounce (2 * t-1) +. 5} }, C = {efeitos: S}; M.easingEffects = S; var P = Math.PI, A = P / 180, D = 2 * P, T = P / 2, I = P / 4, F = 2 * P / 3, L = {claro: função (t) {t.ctx.clearRect (0,0, t.width, t.height)} roundedRect: função (t, s, n, i, a,r) {se (r) {var o = Math.min (r, a / 2, i / 2), s = e + o, l = n + o, u = e + io, d = n + ao; t.moveTo (s, l), s <u && l <d? (t.arc (s, L, O, P, T), t.arc (u, L, O, T, 0), t .arc (u, d, O, 0, t), t.arc (s, d, O, T, P)) :? s <u (t.moveTo (s, n), t.arc (u, L, O, -T, T), t.arc (s, L, O, T, P + T))? l <d (t.arc (s, L, O, P, 0), t .arc (s, d, o, 0, P)): t.arc (s, l, o, -P, P), t.closePath (), t.moveTo (e, n)} mais t.rect (e, n, i, a)}, drawPoint: function (t, e, n, i, a, r) ​​{var o, s, l, u, d, h = (r || 0) * A; if (e && "objeto" == tipo de e && ("[objeto HTMLImageElement]" === (o = e.toString ()) || "[objeto HTMLCanvasElement]" === o)) retorne t.save (), t.translate (i, a), t.rotate (h), t.drawImage (e, -e.width / 2, -e.height / 2, e.width, e.height), anula t.restore ( (! (isNaN (n) || n <= 0);) se) {switch (t.beginPath (), e) {default: t.arc (i, a, n, 0, D), t.closePath (); break; case "triângulo": t.moveTo (i + Math.Sin (h) * n, a-Math.cos (h) * N), H = F +, t.lineTo (i + Math.sen (h) * n, A-Math.cos (h) * N), H = F +, t.lineTo (i + Math.Sin (h) * n, A-Math.cos (h) n *), t.closePath (); break; case "rectRounded" u = n (d = 0,516 * n), s = Math.cos (h + i) * u, l = Math.Sin (h + i) * u, t.arc (é, ai, d, HP, Ht), t.arc (i + l, como, d, Ht, h), t.arc (i + s, l + a, d, h, h + T), t.arc (il, a + s, d, t h + h + P), t.closePath (); break; case "rect": se (r) = {u Math.SQRT1_2! * n, t.rect (iu, au, 2 * de u, 2 u *); ruptura} H + = I; caso "rectRot": s = Math.cos (h) * n, l = Math.Sin (h) * n, t.moveTo (é, ai) t.lineTo (i + l como,), t.lineTo (i + s, a + l), t.lineTo (il, a + s), t.closePath (); break; case "crossRot": h + = I; caso "transversal": s = Math.cos (h) * n, l = Math.Sin (h) * n, t.moveTo (é, ai) t.lineTo (i + s, a + l), t.moveTo (i + l, as), t.lineTo (il, a + s); break; case "estrela": s = Math.cos (h) * n, l = Math.Sin (h) * n, t.moveTo (é, ai), t.lineTo (i + s, a + l), t.moveTo (i + l, as), t.lineTo (il, a + s), I + s = h = Math.cos (h) * n, l = Math.Sin (h) * n, t.moveTo (é, ai), t.lineTo (i + s, a + l) t.moveTo (i + l, as), t.lineTo (il, a + s); break; "linha" processo: s = Math.cos (h) * n , l = Math.Sin (h) * n, t.moveTo (é, ai), t.lineTo (i + s, a + l); break; case "traço": t.moveTo (i, a), t.lineTo (i + Math.cos (h) * n, a + Math.Sin (h) * n)} t.fill () t.stroke ()} _} isPointInArea: função (T, e) { return tx> e.left-1e-6 && t.x <e.right + 1e-6 && t.y> e.top-1e-6 && t.y <e.bottom + 1e-6}, clipArea: function (t, e) {t.save () t.beginPath () t.rect (e.left, e.top, e.right-e.left, e.bottom-e.top) t.clip ()}, unclipArea : função (t) {t.restore ()}, lineTo: função (t, e, n, i) {var a = n.steppedLine; if (a) {if ("middle" === a) {var r = (e.x + nx) /2;t.lineTo (r, i ny:? ey)! t.lineTo (? r, i ey ny)} else "depois" a && i === || "depois"! == a && i? t.lineTo (ex, ny): t.lineTo (nx, ey); t.lineTo (nx, ny)} else n.tension? t.bezierCurveTo (i? e.controlPointPreviousX:e.controlPointNextX, i e.controlPointPreviousY: e.controlPointNextY, i n.controlPointNextX: n.controlPointPreviousX, i n.controlPointNextY: n.controlPointPreviousY nx, NY): t.lineTo (nx, Nova Iorque)}} O = L; M.clear = L.clear, M.drawRoundedRectangle = function (t) {t.beginPath (), L.roundedRect.apply (L, argumentos)}; var R = {_ set: function (t, e ) {return M.merge (this [t] || (this [t] = {}), e)}}; R._set ("global", {defaultColor: "rgba (0,0,0,0.1) ", defaultFontColor:" # 666 ", defaultFontFamily:" 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif ", defaultFontSize: 12, defaultFontStyle:" normal ", defaultLineHeight: 1.2, showLines :! 0}) ; var z = R, N = M.valueOrDefault; var B = {toLineHeight: function (t, e) {var n = ("" + t) .match (/ ^ (normal | (\ d + (?: \. \ d +)?) (px | em |%)?) $ /); if (! n || "normal" === n [1]) retorna 1,2 * e; switch (t = + n [2],n [3]) {case "px": retorna t; case "%": t / = 100} retorna e * t}, paraPadding: function (t) {var e, n, i, a; retorna M.isObject ? (t) (e = + t.top || 0, n = + t.right || 0, i = + t.bottom || 0, a = + t.left || 0): e = n = i = a = + t || 0, {superior: e, direita: n, inferior: i, esquerda: a, altura: e + i, largura: a + n}}, _ parseFont: função (t) {var e = z.global, N = N (t.fontSize, e.defaultFontSize), i = {família: N (t.fontFamily, e.defaultFontFamily), a altura da linha: M.options.toLineHeight (N (t.lineHeight, e. defaultLineHeight), n), tamanho: n, estilo: N (t.fontStyle, e.defaultFontStyle), peso: null, string: ""}; return i.string = function (t) {return! t || M. isNullOrUndef (tamanho da t) || M.isNullOrUndef (família t)? null: (t.style?t.style+ "": "") + (t.weight? t.weight + "": "") + t .size + "px" + t.family} (i), i}, resolve: function (t, e, n, i) {var a, r, o, s =! 0; para (a = 0, r = t.length; a <r; ++ a) if (void 0! == (o = t [a]) && (void 0!== e && "função" == tipo de o && (o = o (e), s =! 1), nulo 0! == n && M.isArray (o) && (o = o [n], s =! 1), void 0! == o)) retorna i &&! s && (i.cacheable =! 1), o}}, E = {_ fatorize: function (t) {var e, n = [], i = Math.sqrt (t ); para (e = 1; e <i; e ++) t% e == 0 && (n.push (e), n.push (t / e)); return i === (0 | i) && n. push (i), n.sort ((função (t, e) {retorno te})). pop (), n}, log10: Math.log10 || função (t) {var e = Math.log (t ) * Math.LOG10E, n = Math.round (e); return t === Math.pow (10, n)? N: e}}, W = E; M.log10 = E.log10; var V = M, H = C, j = O, q = B, U = W, Y = {getRtlAdapter: função (t, e, n) {retorno t? Função (t, e) {retorno {x: função (n) {return t + t + pt}, setWidth: function (t) {e = t}, textAlign: function (t) {return "center" === t? t: "right" === t? "left" : "right"}, xPlus: function (t, e) {return te}, leftForLtr: function (t, e) {return te}}} (e, n): {x:função (t) {retornar t}, setWidth: função (t) {}, textAlign: função (t) {retornar t}, xPlus: função (t, e) {retornar t + e}, leftForLtr: function (t, e) {return t}}}, substituiTextDirection: function (t, e) {var n, i; "ltr"! == e && "rtl"! == e || (i = [(n = t.canvas. estilo) .getPropertyValue ( "direção"), n.getPropertyPriority ( "direção")], n.setProperty ( "direção", e, "importante") t.prevTextDirection = i)}, restaure TextDirection: function (t) { var e = t.prevTextDirection; void 0! == e && (excluir t.prevTextDirection, t.canvas.style.setProperty ("direção", e [0], e [1]))}}; V.easing = H , V.canvas = j, V.opções = q, V.math = U, V.rtl = Y; var G = função (t) {V.extend (this, t), this.initialize.apply (this, argumentos)}; V.extend (G.prototype, {_ type: void 0, initialize: function () {this.hidden =! 1}, pivot: function () {var t = this; return t._view || ( t._view = V.estender ({}, t._model)), t._start = {}, t}, transição: function (t) {var e = this, n = e._model, i = e._start, a = e._view ; return n && 1! == t? (a || (a = e._view = {}), i || (i = e._start = {}), função (t, e, n, i) {var a , R, O, s, L, L, d, h, c, f = Object.keys (s); para (a = 0, r = f.length; um <r; ++ a) se (u = n [o = f [a]] e.hasOwnProperty (o) || (e [o] = u), (s = e [o]) == u && "_"! == o [0]) {if (t.hasOwnProperty (o) || (t [o] = s), (d = tipo de u) === tipo de (l = t [o])) if ("string" === d) { if ((h = k (l)). valid && (c = k (u)). valid) {e [o] = c.mix (h, i) .rgbString (); continue}} else if (V. isFinite (l) && V.isFinite (u)) {e [o] = + l (l) * i; continuar} e [O] = u}} (i, a, n,), e) :( e t. _view = V.extend ({}, n), e._start = zero, e)}, tooltipPosition: função () {return {x: this._model.x, y: this._model.y}}, hasValue: function () {return V.isNumber (this._model.x) && V.isNumber (this._model.y)}}), G.extend = V.inherits; var X = G, K = X.extend ({chart : null,Passo corrente: 0, numSteps: 60, facilitando: "" tornar nulo, onAnimationProgress: nulo, onAnimationComplete: null}), Z = K; Object.defineProperty (K.prototype, "objeto animação", {obter: função () { return this}}), Object.defineProperty (K.prototype, "chartInstance", {get: function () {return this.chart}, configure: function (t) {this.chart = t}}), z._set ("global", {animação: {duration: 1e3, facilitando: "comfortOutQuart", onProgress: V.noop, onComplete: V.noop}}); var $ = {animações: [], request: null, addAnimation: function (t, e, n, i) {var a, r, o = this.animations; for (e.chart = t, e.startTime = Date.now (), e.duration = n, i || (t .animating =! 0), a = 0, r = o.length; a <r; ++ a) if (o [a] .chart === t) retorna nulo (o [a] = e); o .push (e), 1 === comprimento.&& this.requestAnimationFrame ()}, cancelAnimation: função (t) {var e = V.findIndex (this.animations, (function (e) {return e.chart === t})); - um == e &&(this.animations.splice (e, 1), t.animating =! 1)}, requestAnimationFrame: function () {var t = this; null === t.request && (t.request = V.requestAnimFrame.call ( janela, (function () {t.request = null, t.startDigest ()})))}, comece a digerir: function () {this.advance () this.animations.length> 0 && this.requestAnimationFrame ()}, avanço : function () {para (var t, e, n, i, a = this.animations, r = 0; r <comprimento.a;) e = (t = a [r]). chart, n = t. numSteps, i = Math.floor ((Date.now () - /t.duration*n t.startTime)) + 1, t.currentStep = Math.min (i, n), V.callback (t.render, [e, T], e), V.callback (t.onAnimationProgress, [t], e), t.currentStep> = n? (V.callback (t.onAnimationComplete, [t], e), e.animating = 1, a.splice (r, 1)): ++ r}}, J = V.options.resolve, Q = [ "impulso", "pop", "mudança", "tala", "unshift" ]; função tt (t, e) {var n = t._chartjs; if (n) {var i = n.listeners, a = i.indexOf (e); - 1! == a && i.splice (a, 1), i.length> 0 || (Q.forEach ((function (e) {delete t [e]}))), delete t._chartjs)}} var et = function (t, e) {this.initialize (t, e)}; V.extend (et.prototype, {datasetElementType: nulo, tipo de elemento de dados: nulo, _datasetElementOptions: [ "cor do fundo", "borderCapStyle", "cor fronteira", "borderDash", " borderDashOffset "," borderJoinStyle "," borderWidth "], _ dataElementOptions: [" backgroundColor "," borderColor "," borderWidth "," pointStyle "], inicialize: function (t, e) {var n = this; n.chart = . t, ​​= e n.index, n.linkScales () n.addElements () n._type = n.getMeta () tipo}, índice de actualização de função (t)} = {t this.index, escalas de ligação: função () {var t = this.getMeta (), e = this.chart, n = e.scales, i = this.getDataset (), a = e.options.scales; null! == t.xAxisID && t.xAxisID em n &&! i.xAxisID || (t.xAxisID = i.xAxisID || a.xAxes [0] .id), nulo! == t.yAxisID && t.yAxisID em n &&! i.yAxisID || (t.yAxisID = i.yAxisID || a.yAxes [0] .id)}, getDataset: function () {retorna this.chart.data.datasets [this.index]}, getMeta: function () {retorna this.chart.getDatasetMeta (this.index)}, getScaleForId: function (t ) {retorna this.chart.scales [t]}, _ getValueScaleId: function () {retorna this.getMeta (). yAxisID}, _ getIndexScaleId: function () {retorna this.getMeta (). xAxisID}, _ getValueScale: function () {retornar this.getScaleForId (this._getValueScaleId ())}, _ getIndexScale: function () {retornar this.getScaleForId (this._getIndexScaleId ())}, redefinir: function () {this._update (! 0)}, destruir: function () {this._data && tt (this._data, this)}, createMetaDataset: function () {var t = this.datasetElementType; retorna t && new t ({_ chart: this.chart, _datasetIndex: this.index})}, createMetaData : função (t) {var e = isto.dataElementType; return e && new e ({_ chart: this.chart, _datasetIndex: this.index, _index: t})}, addElements: function () {var t, e, n = this.getMeta (), i = this.getDataset () .data || [] a = n.data; para (t = 0, e = i.length; t <s; ++ t) um [a] = uma [a] || this.createMetaData ( t); n.dataset = n.dataset || this.createMetaDataset ()}, addElementAndReset: function (t) {var e = this.createMetaData (t); this.getMeta (). data.splice (t, 0, e), this.updateElement (e, t ,! 0)}, buildOrUpdateElements: function () {var t, e, n = isso, i = n.getDataset (), a = i.data || (i.data = []); n._data == um && (n._data && tt (n._data, n), um && Object.isExtensible (a) && (e = n, (t = a) ._ chartjs t._chartjs.listeners!?. empurrão (e) :( Object.defineProperty (t, "_" chartjs {configuráveis: 0, enumeráveis: 1, valor: {ouvintes: [e]}}), Q.forEach ((função (e) {var n = "onData" + e.charAt (0) .toUpperCase (+ e.slice (1), i = t [e]); objecto.defineProperty (t, e, {configurable :! 0, enumerable :! 1, valor: function () {var e = Array.prototype.slice.call (argumentos), a = i.apply (this, e); return V .each (t._chartjs.listeners, (function (t) {"function" == typeof t [n] && t [n]. aplique (t, e)})), a}})})))), n._data = a), n.resyncElements ()} _, configure: função () {this._config = V.merge ({}, [this.chart.options.datasets [this._type] this.getDataset () ], {fusão função :! (t, s, N) { "_ meta" == T && "dados" == t && V._merger (t, s, N)}})}, _ actualização: função (t) {este ._configure (), this._cachedDataOpts = null, this.update (t)}, atualização: V.noop, transição: function (t) {for (var e = this.getMeta (), n = e.data || [], i = n.length, a = 0, um <i; ++ um) n [a] .transition (t); e.dataset e.dataset.transition && (t)}, desenhar: função () {var t = this.getMeta (), e = t.data || [], n = e.length, i = 0; para (t.dataset t.dataset.draw && (); i <n; i ++) e [ i].draw ()}, getStyle: function (t) {var e, n = this.getMeta (), i = n.dataset; retorna this._configure (), i && void 0 === t? e = this._resolveDatasetElementOptions (i || {}) :( t = t || 0, e = this._resolveDataElementOptions (n.data [t] || {}, t)), 1 == == null && e.fill e.fill! | | (e.backgroundColor = e.borderColor), e}, _ resolveDatasetElementOptions: function (t, e) {var n, i, a, r, o = this, s = o.chart, l = o._config, u = t.custom || {}, d = s.options.elements [o.datasetElementType.prototype._type] || {}, h = o._datasetElementOptions, c = {}, F = {gráfico: s, conjunto de dados: o .getDataset () datasetIndex: o.index, pairar e}; para (n = 0, i = h.length; n <i; n ++) a = h [n], r = e "pairar"? + a.charAt (0) .toUpperCase () + a.slice (1): a, c [a] = J ([u [r], l [r], d [r]], f); retorno c }, _ resolveDataElementOptions: function (t, e) {var n = isto, i = t &&.custom, a = n._cachedDataOpts; if (a &&! i) retorna a; var r, o, s, l, u = n. gráfico, n._config = d, h = u.options.elements [n.dataElementType.prototype._type] || {}, c = n._dataElementOptions, f = {}, L = {gráfico: u, o índice de dados: e, conjunto de dados: n.getDataset () datasetIndex: n.index}, P = {cacheable: i}; if (i = i || {}, V.isArray (c)) em (o = 0, s = c.length; o <s; ++ o) f [l = c [ o]] = J ([i [l], d [l], h [l]], g, e, p); caso contrário, para (o = 0, s = (r = Object.keys (c)). comprimento; o <s; ++ O) f [l = r [O]] = J ([i [l], d [c [l]], d [l], h [l]], g, e , p); return p.cacheable && (n._cachedDataOpts = Object.freeze (f)), f}, removeHoverStyle: function (t) {V.merge (t._model, t. $ previousStyle || {}), delete t. $ previousStyle}, setHoverStyle: function (t) {var e = this.chart.data.datasets [t._datasetIndex], n = t._index, i = t.custom || {}, a = t._model , r = V.getHoverColor; t $ previousStyle = {cor de fundo: a.backgroundColor, cor fronteira: a.borderColor, a largura da borda: a.borderWidth} a.backgroundColor = J ([i.hoverBackgroundColor, e.hoverBackgroundColor, r (a. .backgroundColor)], nulo 0, n), a.borderColor = J ([i.hoverBorderColor, e.hoverBorderColor, r (a.borderColor)], nulo 0, n), a.borderWidth = J ([i.hoverBorderWidth, e.hoverBorderWidth, a.borderWidth], nulo 0, n)}, _ removeDatasetHoverStyle: function () {var t = this.getMeta (). conjunto de dados; t && this.removeHoverStyle (t)}, _ setDatasetHoverStyle: function () {var t, e, n, i, a, r, o = this.getMeta (). conjunto de dados , S = {}; (! O), se {para (r = o._model, um this._resolveDatasetElementOptions = (o, 0) t = 0, e = (i = Object.keys (a)) comprimento. t <e; ++ t) s [n = i [t]] = r [n], r [n] = a [n]; o. $ previousStyle = s}}, resyncElements: function () {var t = this.getMeta (), e = this.getDataset () de dados, n = t.data.length, i = e.length; i <n t.data.splice (i, ni): i> n && este.. insertElements (n, in)}, insertElements: function (t, e) {for (var n = 0; n <e; ++ n) this.addElementAndReset (t + n)}, onDataPush: function () {var t = arguments.length; this.insertElements (. this.getDataset () data.length-t, t)}, onDataPop: função () {este.. GetMeta () data.pop ()}, onDataShift: função () {this.getMeta () data.shift ()}, onDataSplice:.. Função (T, E) {this.getMeta () data.splice (t , e), this.inserirElements (t, argumentos.length-2)}, onDataUnshift: function () {this.inserirElements (0, argumentos.length)}}), et.extend = V.inherits; var nt = et , it = 2 * Math.PI; função em (t, e) {var n = e.startAngle, i = e.endAngle, a = e.pixelMargin, r = a / e.outerRadius, o = ex, s = ey; t.beginPath () t.arc (O, S, e.outerRadius, nenhum, i + r) e.innerRadius> a (r = a / e.innerRadius, t.arc (O, S ,? e.innerRadius-a, r i +, NR, 0)): t.arc (O, S, a, i + Math.PI / 2, n-Math.PI / 2), t.closePath () função t.clip ()} rt (t, e, n) {var i = "inner" === e.borderAlign; i? (t.lineWidth = 2 * e.borderWidth, t.lineJoin = "round") : (t.lineWidth = e.borderWidth, t.lineJoin = "chanfro"), n.fullCircles && function (t, e, n, i) {var a, r = n.endAngle; for (i && (n.endAngle = n .startAngle + que, em (T, N), n.endAngle = r, n.endAngle === n.startAngle && && n.fullCircles (n.endAngle + = lo, n.fullCircles -)), t.beginPath () t.arc (nx, NY, n.innerRadius, n. startAngle +-lo, n.startAngle, 0) = 0 um ;! um <n.fullCircles; ++ um) t.stroke (); para (t.beginPath () t.arc (nx, NY, e. raio externo, n.startAngle, n.startAngle + lo), a = 0; a <n.fullCircles; ++ um) t.stroke ()} (t, s, n, i), i && a (T, N), t.beginPath () t.arc (nx, NY, e.outerRadius, n.startAngle, n.endAngle) t.arc (nx, NY, n.innerRadius, n.endAngle, n.startAngle ,! 0) , t.closePath () t.stroke ()} z._set ( "globais" {elementos: {arco: {cor de fundo: z.global.defaultColor, cor da borda: "# fff", largura da borda: 2, alinhamento de fronteira " centro "}}}); var ot = X.extend ({_ type:" arc ", inLabelRange: function (t) {var e = this._view; return !! e && Math.pow (te.x, 2) <Math .pow (e.radius + e.hoverRadius, 2)}, inRange: função (t, e) {var n = this._view; if (n) {for (var i = V.getAngleFromPoint (n, {x: t, y: e}), a = i.angle, r = i.distance, o = n.startAngle, s = n .endAngle; s <o;) s + = it; for (; a> s;) a- = it; for (; a <o;) a + = it; var l = a> = o && a <= s, u = r> = n.innerRadius && r <= n.outerRadius; return l &&} return! 1}, getCenterPoint: function () {var t = this._view, e = (t.startAngle + t.endAngle) / 2, n = ( t.innerRadius t.outerRadius +) / 2; {retorno x + Math.cos (e) * n T.x, y: t.y + Math.Sin (e) n *}}, getArea: () função (var t = this._view; return Math.PI * ((t.endAngle-t.startAngle) / (2 * Math.PI)) * (Math.pow (t.outerRadius, 2) -Math.pow (t .innerRadius, 2))}, dica de ferramentaPosition: function () {var t = this._view, e = t.startAngle + (t.endAngle-t.startAngle) / 2, n = (t.outerRadius-t.innerRadius) / 2 + t.innerRadius; return {x: t.x + Math.cos (e) * n, y: t.y + Math.sin (e) * n}}, draw: function () {var t, e = this._chart.ctx, n = this._view, i = "interior" === n.borderAlign 0,33: 0, a = {x: nx,y: ny, raio interno: n.innerRadius, raio exterior: Math.max (n.outerRadius-i, 0), a margem de pixel: i, Ângulo inicial: n.startAngle, endAngle: n.endAngle, círculos cheios: Math.floor (n.circumference / it)}; se (e.save () e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, a.fullCircles) {para (a.endAngle = a.startAngle + lo, e.beginPath ( ) e.arc (ax, Ay, a.outerRadius, a.startAngle, a.endAngle) e.arc (ax, Ay, a.innerRadius, a.endAngle, a.startAngle ,! 0) e.closePath () t = 0; t <a.fullCircles; ++ t) e.fill (); a.endAngle = a.startAngle + n.circumference%} que e.beginPath () e.arc (ax, ay , a.outerRadius, a.startAngle, a.endAngle) e.arc (ax, ay! a.innerRadius, a.endAngle, a.startAngle, 0), e.closePath () e.fill () n.borderWidth && temperatura ambiente (e, n, a), e.restore ()}}) = r V.valueOrDefault, lt = z.global.defaultColor; z._set ( "globais" {elementos: {linha: {tensão : 0,4, a cor de fundo: lt, a largura da borda: 3, a cor da borda: lt,borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "mitra", capBezierPoints :! 0, preenchimento :! 0}}}); var ut = X.extend ({_ type: "line", draw : function () {var t, e, n, i = isto, a = visualização i, r = i._chart.ctx, o = a.spanGaps, s = i._children.slice (), l = z. global, u = l.elements.line, d = 1, h = i._loop; se (s.length) {if (i._loop) {para (t = 0; t <s.length; t ++ ) se (e = V.previousItem (s, t),! s [t] ._ view.skip && e._view.skip) {s = s.slice (t) .concat (s.slice (0, t)), h = O; ruptura} h && s.push (s [0])} para (r.save () = r.lineCap a.borderCapStyle || u.borderCapStyle, r.setLineDash && r.setLineDash (a.borderDash || u. borderDash) r.lineDashOffset = r (a.borderDashOffset, u.borderDashOffset) r.lineJoin = a.borderJoinStyle || u.borderJoinStyle, r.lineWidth = r (a.borderWidth, u.borderWidth) r.strokeStyle = a.borderColor || l.defaultColor, r.beginPath () (n = s [0] ._ vista) .skip || (r.moveTo (nx, n.y), d = 0), t = 1; t <s.length; ++ t) = s n [t] ._ vista, e = -1 === V.previousItem d (S, T): s? [d] n.skip || (d == 1 && t-O || === -1 d r.moveTo (nx, NY):!? V.canvas.lineTo (r, e._view, n ), d = t); h && r.closePath (), r.stroke (), r.restore ()}}}), dt = V.valueOrDefault, ht = z.global.defaultColor; função ct (t) {var e = this._view; voltar !! e && Math.abs (te.x) <e.radius + e.hitRadius} z._set ( "globais" {elementos: {ponto: estilo de 3 pontos:: {raio "círculo" , backgroundColor: ht, borderColor: ht, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1}}}); var ft = X.extend ({_ type: "point", inRange: function (t, e ) {var n = this._view; return !! n && Math.pow (tn.x, 2) + Math.pow (pt.y, 2) <Math.pow (n.hitRadius + n.radius, 2)}, inLabelRange: ct, inXRange: ct, inYRange: function (t) {var e = this._view; return !! e && Math.abs (te.y) <e.radius + e.hitRadius}, getCenterPoint:function () {var t = this._view; return {x: tx, y: ty}}, getArea: function () {return Math.PI * Math.pow (this._view.radius, 2)}, dica de ferramenta function () {var t = this._view; return {x: tx, y: ty, padding: t.radius + t.borderWidth}}, draw: function (t) {var e = this._view, n = this ._chart.ctx, i = e.pointStyle, um e.rotation =, r = e.radius, o = ex, ey = S, L = z.global, u = l.defaultColor; e.skip || (void 0 === t || V.canvas._isPointInArea (s, t)) && (n.strokeStyle = e.borderColor || u, n.lineWidth = dt (e.borderWidth, l.elements.point.borderWidth) n.fillStyle = e.backgroundColor || u, V.canvas.drawPoint (n, i, r, o, s, a))}}), gt = z.global.defaultColor; function pt (t) {return t && void 0! == t.width} função mt (t) {var e, n, i, a, r; return pt (t)? (R = t.width / 2, e = tx-r, n = t. x + r, i = Math.min (ty, t.base), a = Math.max (ty, t.base)) :( r = t.height / 2, e = Math.min (tx, t. base), n = Math.max (tx, t.base), i = ty-r, a = t.y + r), {à esquerda: e, topo: i, direita: n, em baixo:a}} função vt (t, e, n) {retornar t === e? n: t === n? e: t} função bt (t, e, n) {var i, a, r, o , s = t.borderWidth, l = function (t) {var e = t.borderSkipped, n = {}; retorna e? (t.horizontal? t.base> tx && (e = vt (e, "left", "right")): t.base <ty && (e = vt (e, "bottom", "top")), n [e] =! 0, n): n} (t); retorna V.isObject ( ? s) (i = + s.top || 0, a = + s.right || 0, r = + s.bottom || 0, o = + s.left || 0): i = a = r = o = + s || 0, {T: l.top || i <0 0: i> n n: i, r: l.right || um <0 0: a> e e ?: a, b: l.bottom || r <0? 0: r> n? n: r, l: l.left || o <0? 0: o> e? e: o}} função xt (t, e, n) {var i = nulo === e, a = nulo === n, r =! (! t || i && a) && mt (t); retorna r && (i || e> = r.left && e < = r.right) && (a || n> = r.top && n <= r.bottom)} z._set ( "globais" {elementos: {retângulo: {background cor: gt, borderColor: gt, fronteira kipped: "bottom ", borderWidth: 0}}}); var yt = X.estender ({_ type: "rectangle", draw: function () {var t = this._chart.ctx, e = this._view, n = function (t) {var e = mt (t), n = right. -e.left, i = e.bottom-e.top, um bt = (T, N / 2, i / 2); {return exterior: {x: e.left, y: e.top, w: n , h: i}, interno: {x: e.left + al, y: em e.top +, w: na.la.r, h: ia.ta.b}}} (e), I = n .outer, a = n.inner; t.fillStyle = e.backgroundColor, t.fillRect (lx, ly, iw, IH), iw === === && aw L.h ah || (t.save () t.beginPath () t.rect (lx, ly, iw, IH), t.clip () t.fillStyle = e.borderColor, t.rect (ax, Ay, aw, ah), t.fill ( "evenodd"), t.restore ())}, height: function () {var t = this._view; retorna t.base-ty}, inRange: function (t, e) {return xt (this._view, t, e)}, inLabelRange: function (t, e) {var n = this._view; return pt (n)? xt (n, t, null): xt (n, null, e)}, inXRange: function (t) {return xt (this._view, t, null)}, inYRange: function (t) {return xt (this._view, null, t)}, getCenterPoint: function () {var t, e, n = this._view;Retorno pt (n)? (t = nx, e = (n.y + n.base) / 2) :( t = (n.x + n.base) / 2, e = ny), {x: t , y: e}}, getArea: function () {var t = this._view; return pt (t)? t.width * Math.abs (ty-t.base): t.height * Math.abs (tx -t.base)}, tooltipPosition: function () {var t = this._view; return {x: tx, y: ty}}}), _ t = {}, kt = ot, wt = ut, Mt = ft , St = yt; _t.Arc = kt, _t.Line = wt, _t.Point = Mt, _t.Retângulo = St; var Ct = V._ reprovado, Pt = V.valueOrDefault; function At (t, e, n ) {var i, a, r = n.barThickness, o = e.stackCount, s = e.pixels [t], l = V.isNullOrUndef (r)? função (t, e) {var n, i, a , R, O = t._length; para (a = 1, r = e.length; um <r; ++ a) o = Math.min (o, Math.abs (s [a] -e [a- 1])); para (a = 0, r = t.getTicks () comprimento;. um <r; ++ a) i = t.getPixelForTick (a), o = a> 0 Math.min (O ,? Math.abs (in)): o, n = i; return o} (e.scale, e.pixels): - 1; return V.isNullOrUndef (r)? (I = l * n.categoryPercentage, a = n .barPercentage) :( i = r * o, a = 1) {pedaço: i / o rácio: um, iniciar: Si / 2}} z._set ( "barra" pairar {: {modo:"label"} {escalas xAxes: [{tipo: "categoria", offset: 0, as linhas de grelha: {linhas de grade offset: 0}}], yAxes: [{tipo: "linear"}]}}), z ._set ("global", {conjuntos de dados: {bar: {categoryPercentage: .8, barPercentage: .9}}}); var Dt = nt.extend ({dataElementType: _t.Rectangle, _dataElementOptions: ["backgroundColor", " borderColor "," borderSkipped "," borderWidth "," barPercentage "," barThickness "," categoryPercentage "," maxBarThickness "," minBarLength "], inicialize: function () {var t, e, n = this; nt.prototype .initialize.apply (n, argumentos), (t = n.getMeta ()). n.getDataset pilha = (). stack, t.bar! = 0, e = n._getIndexScale (). opções, CT ( " gráfico de barras ", e.barPercentage," dimensiona. [x / y] Axes.barPercentage "," dataset.barPercentage "), Ct (" gráfico de barras ", e.barThickness,"escalas. [x / y] Axes.barThickness "," dataset.barThickness "), Ct (" gráfico de barras tipo: i? r: a, fim: i? a: r}} função jt (t, e, n) {vari = n / 2, a = Ht (t, i), r = Ht (e, i ); return {top: r.end, right: a.end, bottom: r.start, left: a.start}} função qt (t) {var e, n, i, a; return V.isObject (t ?) (e = t.top, n = t.right, i = t.bottom, a = t.left): e = n = i = a = t, {topo: e, direita: n, inferior: i , deixou: a}} z._set ( "linha" {Mostrar linhas: 0, spanGaps: 1, hover {modo: "rótulo"} {escalas xAxes: [{type: "categoria", id: "x-axis-0"}], yAxes: [{type: "linear", id: "y-axis-0"}]}}); var Ut = nt.extend ({datasetElementType: _t.Line, dataElementType : _t.Point, _datasetElementOptions: [ "cor de fundo", "borderCapStyle", "cor da borda", "borderDash", "borderDashOffset", "borderJoinStyle" "largura da borda", "cubicInterpolationMode", "preenchimento"] _ opções dataElement: {cor de fundo: "cor de fundo ponto "cor da borda:" ponto borderColor "borderWidth:" ponto borderWidth "hitRadius" pointHitRadius "hoverBackgroundColor" pointHoverBackgroundColor "hoverBorderColor" pointHoverBorderColor "hoverBorderWidth" pointHoverBorderWidth "hoverRadius" pointHoverRadius "estilo ponto:" estilo de ponto " , raio: "pointRadius", rotação: "pointRotation"}, atualização: função (t) {var e, n, i = isto, a = i.getMeta (), r = a.dataset, o = a.data | | [] s = i.chart.options, l = i._config, u = i._showLine = Et (l.showLine, s.showLines); para (i._xScale = i.getScaleForId (a.xAxisID) i._yScale = i.getScaleForId (a.yAxisID), u && (void 0! == l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), r._scale = i._yScale, r. _datasetIndex = i.index, r._children = o, i = r._model._resolveDatasetElementOptions (r) r.pivot ()), e = 0, n = o.length; e <n; ++ e) i.updateElement (O [e], e, t); para (U && 0 ==! r._model.tension && i.updateBezierControlPoints (), e = 0, n = o.length; e <n; ++ e) o [e] .pivot ()}, actualização de elemento: função (t, s, N) {var i,, um R = isso, o = r.getMeta (), s = {t.custom ||}, l = r.getDataset (), u = r.index, d = l.data [e], h = r._xScale, c = r._yScale, f = o.dataset._model, g = r._resolveDataElementOptions (t, e); i = h.getPixelForValue ("objeto" == tipo de d? d: NaN, e, u), a = n c.getBasePixel ():? r.calculatePointY (d, e, u), t._xScale = H, C = t._yScale, t._options = g, t._datasetIndex = u, t. _index = e, t._model = {xi, y: uma, pular: S.SKIP || isNaN (i) || isNaN (um) de raio: g.radius, estilo de ponto: g.pointStyle, rotação: g .rotation, a cor de fundo: g.backgroundColor, cor fronteira: g.borderColor, a largura da borda: g.borderWidth, tensão: Et (s.tension, f f.tension: 0), steppedLine: !! f && f.steppedLine, hitRadius: g.hitRadius}}, _ resolveDatasetElementOptions: function (t) {var e = this, n = e._config, i = t.custom || {}, a = e.chart.options, r = a.elements.line, o = nt.prototype._resolveDatasetElementOptions.apply (e, argumentos); retornar o.spanGaps = Et (n.spanGaps, a.spanGaps), o.tension = Et (n.lineTension, r.tension), o.steppedLine = Wt ( [i.steppedLine, n.steppedLine, r.stepped]), o.clip qt = (Et (n.clip, JT (e._xScale, e._yScale, o.borderWidth))), o}, calculatePointY: função (t, e, n) {var i, a, r, o, s, l, u, d = this.chart, h = this._yScale, c = 0, f = 0; if (h.options.stacked ) {for (s = + h.getRightValue (t), u = (L = d._getSortedVisibleDatasetMetas ()) comprimento, i = 0; i <u && (r = l [i]) == índice n..!; ++ i) a = d.data.datasets [r.index], "linha" === === && R.TYPE r.yAxisID h.id && ((o = + h.getRightValue (a.data [e]) ) <0? F + = o || 0: c + = o || 0); return s <0 H.getPixelForValue (f + s): h.getPixelForValue (c + s)} retorna h.getPixelForValue (t)} .updateBezierControlPoints: function () {var t, e, n, i, a = this.chart, r = this.getMeta (), o = r.dataset._model, s = a.chartArea, l = r.data || []; function u (t, e, n) {retorna Math.max (Math.min (t, n), e)} if (o.spanGaps && (l = l.filter ((function (t) {return! t._model.skip}))), "monotone" === o.cubicInterpolationMode) V.splineCurveMonotone (l); mais para (t = 0, e = comprimento.l; t <e; ++ t) n = l [t] ._ modelo, i = V.splineCurve (modelo V.previousItem (l, t) ._, N, V.nextItem (l, t) ._ modelo, o.tension) n.controlPointPreviousX = i.previous. x, n.controlPointPreviousY = i.previous.y, n.controlPointNextX = i.next.x, n.controlPointNextY = i.next.y; if (a.options.elements.line.capBezierPoints) para (t = 0, e = l.length; t <e; ++ t) n = l [t] ._ modelo, Vt (N, s) && (t> 0 && Vt (l [T-1] ._ modelo, s) && (n. controlPointPreviousX = u (n.controlPointPreviousX, s.left, s.right) n.controlPointPreviousY = u (n.controlPointPreviousY, s.top, s.inferior)), t <l.length-1 && Vt (L [t + 1] ._ modelo, s) && (n.controlPointNextX = u (n.controlPointNextX, s.left, s.right) n.controlPointNextY = u ( n.controlPointNextY, s.top, s.bottom)))}, desenhe: function () {var t, e = this.chart, n = this.getMeta (), i = n.data || [], um = e.chartArea, r = e.canvas, o = 0, s = i.length; para (this._showLine && (t = n.dataset._model.clip, V.canvas.clipArea (e.ctx, {à esquerda: ! t.left 1 === 0: a.left-t.left, direita: 1 === t.right r.width: a.right + t.right, superior: 1 === t .TOP 0: a.top-t.top, inferior: 1 === t.bottom r.height: a.bottom + t.bottom}) n.dataset.draw () V.canvas. unclipArea (e.ctx)); o <s; ++ o) i [o] .draw (a)}, setHoverStyle: função (t) {var e = t_model, n = t._options, i = V .getHoverColor; t $ previousStyle = {cor de fundo: e.backgroundColor, cor fronteira: e.borderColor, a largura da borda: e.borderWidth, raio: e.radius} e.backgroundColor = Et (n.hoverBackgroundColor, i (n.backgroundColor). ), e.cor da borda = Et (i n.hoverBorderColor (n.borderColor)) e.borderWidth = Et (n.hoverBorderWidth n.borderWidth,), e.radius = Et (n.hoverRadius, n.radius)}}), Yt = V.options.resolve; z._set ( "área polar", {escala: {tipo: "lineares" radial linhas angulares: {display: 1}, as linhas de grelha: {circular: 0}, etiquetas de pontos: {display: 1! }, assinala: {beginAtZero :! 0}}, animação: {animateRotate :! 0, animateScale :! 0}, startAngle: -. 5 * Math.PI, legendCallback: function (t) {var e, n, i, um documento = ( "ul"), r = t.data, o = r.datasets, s = r.labels; se (a.setAttribute ( "classe", t.id + "- legenda") o. comprimento) para (e = 0, n = O [0] .data.length; e <n; ++ e) (i = a.appendChild (document.createElement ( "LI")).) appendChild (document.createElement ("span")). style.backgroundColor = o [0] .backgroundColor [e], s [e] && i.appendChild (document.createTextNode (s [e])); retorne a.outerHTML}, legenda:{labels: {generateLabels: function (t) {var e = t.data; return e.labels.length && e.datasets.length? e.labels.map ((função (n, i) {var a = t.getDatasetMeta ( 0), r = a.controller.getStyle (i); retorno {texto: n, fillStyle: r.backgroundColor, estilo acidente vascular cerebral: r.borderColor, largura de linha: r.borderWidth, escondidos: isnan (e.datasets [0] .data [i]) || a.data [i] .hidden, índice: i}})): []}}, onClick: função (t, e) {var n, i, a, r = e.index, o = this.chart; para (n = 0, i = (|| o.data.datasets []) ;. comprimento n <i; n ++) (a = o.getDatasetMeta (n)) de dados [r. ] .hidden =! a.data [r] .hidden; o.update ()}}, dicas de ferramentas: {retornos de chamada: {title: function () {return ""}, label: function (t, e) {return e etiquetas [t.index] + ":" + t.yLabel}}}}); var Gt = nt.extend ({dataElementType: _t.Arc, linkScales: V.noop, _dataElementOptions: ["backgroundColor", "borderColor "" largura fronteira "" align fronteira ""hoverBackgroundColor "," hoverBorderColor "," hoverBorderWidth "], _ getIndexScaleId: function () {retorna this.chart.scale.id}, _ getValueScaleId: function () {retorna this.chart.scale.id}, atualização: function (t) {var e, n, i, a = isto, r = a.getDataset (), o = a.getMeta (), s = a.chart.options.startAngle || 0, l = a._starts = [], u = a._angles = [], d = o.data; para (a._updateRadius () o.count = a.countVisibleElements (), e = 0, n = r.data.length; e <n; e ++ ) l [e] = s, I = a._computeAngle (s), u [e] = i, s + = i; for (e = 0, n = D.Length; e <n; ++ e) d [ e] ._ opções = a._resolveDataElementOptions (d [e], e), a.updateElement (d [e], e, t)}, _ updateRadius: function () {var t = this, e = t.chart, n = e.chartArea, i = e.options, a = Math.min (n.right-n.left, n.bottom-n.top); e.outerRadius Math.max = (a / 2,0), e .innerRadius = Math.max (i.cutoutPercentage e.outerRadius / 100 * i.cutoutPercentage:? 1,0), e.radiusLength = (e.outerRadius-e.innerRadius) / e.getVisibleDatasetCount (), t.outerRadius = e.outerRadius-e.radiusLength * t.index, t.innerRadius = t.outerRadius-e.radiusLength}, updateElement: function (t, e, n) {var i = this, a = i.chart, r = i.getDataset (), o = a.options, s = o.animation, l = a.scale, u = a.data.labels, d = l.xCenter, h = l.yCenter , c = o.startAngle, f = 0 t.hidden: l.getDistanceFromCenterForValue (r.data [e]), g = i._starts [e], p = g + (0 t.hidden: [i._angles e]), m = 0 s.animateScale: l.getDistanceFromCenterForValue (r.data [e]), v = t._options || {}; V.extend (t, {_ datasetIndex: i.index, _index: e , _scale: l, _model: {cor de fundo: v.backgroundColor, cor fronteira: v.borderColor, a largura da borda: v.borderWidth, align fronteira: v.borderAlign, x d, y: h, raio interno: 0, raio exterior: n m ?: f, ângulo inicial: n && s.animateRotate c: g, endAngle: n && s.animateRotate c: p, etiqueta: V.valueAtIndexOrDefault (u, e, U [e])}}), t.pivot ()}, a contagem de elementos visíveis: function () {var t = isso.getDataset (), e = this.getMeta (), n = 0; retorna V.each (e.data, (função (e, i) {isNaN (t.data [i]) || e.hidden || n ++ })), n}, setHoverStyle: function (t) {var e = t._model, n = t._options, i = V.getHoverColor, a = V.valueOrDefault; t. $ previousStyle = {backgroundColor: e.backgroundColor , cor da borda: e.borderColor, fronteira largura: e.borderWidth} e.backgroundColor = a (n.hoverBackgroundColor, i (n.backgroundColor)), e.borderColor = a (n.hoverBorderColor, i (n.borderColor)), e.borderWidth = a (n.hoverBorderWidth, n.borderWidth)}, _ computeAngle: function (t) {var e = this, n = this.getMeta (). count, i = e.getDataset (), a = e. getMeta (); if (isNaN (i.data [t]) || a.data [t] .hidden) retorna 0; var r = {gráfico: e.chart, dataIndex: t, conjunto de dados: i, datasetIndex: e .index}; return Yt ([e.chart.options.elements.arc.angle, 2 * Math.PI / n], r, t)}}); z._set ("pie", V.clone (por exemplo, .doughnut)), z._set ("pie", {cutoutPercentage: 0}); var Xt = Nt, Kt = V.valueOrDefault; z._set ("radar", {spanGaps :! 1, scale: {type: "radialLinear"}, elementos: {line: {fill: "start", tension: 0}}}); var Zt = nt .extend ({datasetElementType: _t.Line, tipo de elemento de dados: _t.Point, balanças de link: V.noop, _datasetElementOptions: [ "cor de fundo", "largura da borda", "cor da borda", "borderCapStyle", "borderDash", "borderDashOffset", " borderJoinStyle "" preenchimento "] _ opções dataElement: {cor de fundo:" cor de fundo ponto "cor da borda:" ponto borderColor "borderWidth:" ponto borderWidth "hitRadius" pointHitRadius "hoverBackgroundColor" pointHoverBackgroundColor "hoverBorderColor" pointHoverBorderColor "hoverBorderWidth" pointHoverBorderWidth "hoverRadius" pointHoverRadius "estilo de ponto:"pointStyle", raio: "pointRadius", rotação: "pointRotation"}, _ getIndexScaleId: function () {retorna this.chart.scale.id}, _ getValueScaleId: function () {retorna this.chart.scale.id}, atualização : função (t) {var e, n, i = isso, a = i.getMeta (), r = a.dataset, o = a.data || [], s = i.chart.scale, l = i ._config; for (void 0! == l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), r._scale = s, r._datasetIndex = i.index, r._children = o, r._loop = 0, = r._model i._resolveDatasetElementOptions (r), r.pivot (), e = 0, n = o.length ;! e <n; ++ e) i.updateElement (O [e] , e, t); para (i.updateBezierControlPoints (), e = 0, n = o.length; e <n; ++ e) o [e] .pivot ()}, elemento de actualização: função (T, e, n) {var i = this, a = t.custom || {}, r = i.getDataset (), o = i.chart.scale, s = o.getPointPositionForValue (e, r.data [e]), l = i._resolveDataElementOptions (t, s) = u i.getMeta () dataset._model, d = n o.xCenter:.? sx, h = N O ?.ycenter: sy; t._scale = O, t._options = l, t._datasetIndex = i.index, t._index = e, t._model = {x: d, y: h, pular: a.skip || isNaN (d) || isNaN (h), de raio: l.radius, estilo de ponto: l.pointStyle, rotação: l.rotation, a cor de fundo: l.backgroundColor, cor fronteira: l.borderColor, a largura da borda: l.borderWidth, tensão: Kt (tensão, tensão?: 0), hitRadius: l.hitRadius}}, _ resolveDatasetElementOptions: function () {var t = this, e = t._config, n = t.chart.options, i = nt .prototype._resolveDatasetElementOptions.apply (t, argumentos); retornar i.spanGaps = Kt (e.spanGaps, n.spanGaps), i.tension = Kt (e.lineTension, n.elements.line.tension), i}, updateBezierControlPoints: function () {var t, e, n, i, a = this.getMeta (), r = this.chart.chartArea, o = a.data || []; função s (t, e, n) {return Math.max (Math.min (t, n), e)} para (a.dataset._model.spanGaps && (o = o.filter ((function (t) {return! t._model.skip}))) ), t = 0, e = o.length; t <e; ++ t) = N O [t] ._ modelo, i = V.splineCurve (V.previousItem (O, T ,! 0) ._ modelo, n, V.nextItem (O, T ,! 0) ._ modelo, n.tension) n.controlPointPreviousX = s (i.previous.x, r .left, r.right) n.controlPointPreviousY = s (i.previous.y, r.top, r.bottom) n.controlPointNextX = s (i.next.x, r.left, r.right) n.controlPointNextY = s (i.next.y, r.top, r.bottom)}, setHoverStyle: função (t) {var e = t__model, n = opções de t, i = V.getHoverColor; t. $ previousStyle = {cor de fundo: e.backgroundColor, cor fronteira: e.borderColor, a largura da borda: e.borderWidth, raio: e.radius} e.backgroundColor = Kt (n.hoverBackgroundColor, i (n.backgroundColor)), e.borderColor = Kt (n.hoverBorderColor, i (n.borderColor)), e.borderWidth = Kt (n.hoverBorderWidth, n.borderWidth) e.radius = Kt (n.hoverRadius, n.radius)}}); z. _set ( "dispersão", {{pairar modo: "individuais"} {escalas xAxes: [{ID: tipo "eixo x-1",: "linear" posição: "fundo"}], yAxes: [{id: "eixo dos y-1 "tipo:" linear "posição," esquerda "}]}, pontas da ferramenta: {chamadas de retorno: {título: função () {return" "}, a etiqueta: função (t) {return" ( " + t.xLabel + "," + t.yLabel + ")"}}}}), z._set ("global", {conjuntos de dados: {scatter: {showLine :! 1}}}); var $ t = {bar : Dt, bolha: Ft, rosca: Nt, horizontalBar: Bt, linha: Ut, polarÁrea: Gt, torta: Xt, radar: Zt, dispersão: Ut}; função Jt (t, e) {retornar t.nativo? { x: tx, y: ty}: V.getRelativePosition (t, e)} função Qt (t, e) {var n, i, a, r, o, s, l = t._getSortedVisibleDatasetMetas (); for (i = 0, r = l.length; i <r; i ++) para (a = 0, o = (n = l [i] .data) .Length; um <o; ++ a) (s = n [a]) ._ view.skip || e (s)} função te (t, e) {var n = []; retorna Qt (t, (função (t) {t.inRange (ex, ey) && n. push (t)})), n} função ee (t, e, n, i) {var a = Number.POSITIVE_INFINITY, r = []; retorna Qt (t, (função (t) {if (! n | | t.inRange (ex, ey)) {var o = t.getCenterPoint (), s = i (e, o);s <a? (r = [t], a = s): s === a && r.push (t)}})), r} função ne (t) {var e = -1! == t.indexOf ("x"), n = -1! == t.indexOf ("y"); função de retorno (t, i) {var a = e? Math.abs (tx-ix): 0, r = n? Math.abs (ty-iy): 0; return Math.sqrt (Math.pow (a, 2) + Math.pow (r, 2))}} função ie (t, e, n) {var i = Jt (e, t); n.axis = n.axis || "x"; var a = ne (n.axis), r = n.interruptores? te (t, i): ee (t, i ,! 1 , a), o = []; retorna r.length? (t._getSortedVisibleDatasetMetas (). forEach ((function (t) {var e = t.data [r [0] ._ index]; e &&! e._view. pular && o.push (e)})), o): []} var ae = {modos: {única: função (t, e) {var n = Jt (e, t), i = []; retornar Qt ( t, (função (t) {if (t.inRange (nx, ny)) retorna i.push (t), i})), i.slice (0,1)}, label: ie, index: ie, conjunto de dados: function (t, e, n) {vari = Jt (e, t); n.axis = n.axis || "xy"; var a = ne (n.axis), r = n.interligar? te (t, i): ee (t, i ,! 1, a); retorna r.length> 0 && (r = t.getDatasetMeta (r [0]._datasetIndex) .data), r}, "eixo x": function (t, e) {return ie (t, e, {intersect :! 1})}, point: function (t, e) {return te ( t, Jt (e, t))}, mais próximo: function (t, e, n) {var i = Jt (e, t); n.axis = n.axis || "xy"; var a = ne ( n.axis); return ee (t, i, n.intersect, a)}, x: function (t, e, n) {var i = Jt (e, t), a = [], r =! 1 ; return Qt (t, (função (t) {t.inXRange (ix) && a.push (t), t.inRange (ix, iy) && (r =! 0)})), n.intersect &&! r && ( a = []), a}, y: função (t, e, n) {var i = Jt (e, t), a = [], r =! 1; retorna Qt (t, (função (t)) {t.inYRange (iy) && a.push (t), t.inRange (lx, ly) && (r = 0)})), n.intersect &&! r && (a = []), um}}}, re = V. extender; função oe (t, e) {retornar V.onde (t, (função (t) {retornar t.pos === e}))} função se (t, e) {retornar t. ordenar ((função (t, n) {vari = e? n: t, a = e? t: n; retornar i.weight === a.weight? i.index-a.index: i.weight- a.weight}))} function le (t, e, n, i) {retornar Math.max (t [n], e [n]) + Math.max (t [i], e [i])} função ue (t, e, n) {var i, a, r = n.box, o ? = t.maxPadding; se (n.size && (t [n.pos] - = n.size) n.size = n.horizontal r.height: r.width, t [n.pos] + = n. tamanho, r.getPadding) {var s = r.getPadding (); o.top = Math.max (o.top, s.top), o.left = Math.max (o.left, s.left), o.bottom = Math.max (o.bottom, s.bottom) o.right = Math.max (o.right, s.right)} if (i = e.outerWidth-le (O, T, "esquerda "," right "), a = e.outerHeight-le (o, t," top "," bottom "), i! == tw || a! == th) return tw = i, th = a, n.horizontal? i! == tw: a! == th} função de (t, e) {var n = e.maxPadding; função i (t) {var i = {left: 0, top: 0, right : 0, bottom: 0}; return t.forEach ((function (t) {i [t] = Math.max (e [t], n [t])})), i} return i (t? [ "left", "right"]: ["top", "bottom"])} função ele (t, e, n) {vari, a, r, o, s, l, u = []; for ( i = 0, a = T.Length; i <a i ;. ++) (O = (r = t [i]) caixa) .Update (r.|| largura EW, r.height || eh, de (r.horizontal, e)), L (e, n, r) && (l! = 0 && u.length (s! = 0)) o. fullWidth || u.push (r); return s && he (u, e, n) || l} função ce (t, e, n) {var i, a, r, o, s = n.padding, l = ex, u = ey; para (i = 0, a = T.Length; a i <; i ++) caixa = o (r = t [i]), r.horizontal (o.left = O.?. completo s.left largura: e.left, o.right = o.fullWidth n.outerWidth-s.right: e.left + EW, o.top = u, u + = o.bottom o.height, o. largura = o.right-o.left, u = o.bottom) :( o.left = l, l = + o.right o.width, o.top = e.top, o.bottom = + e.top eh, o.height = o.bottom-o.top, l = o.right) ex = l, ey = u} z._set ( "global" {disposição: {padding: {top: 0, direita: 0, inferior: 0, esquerda: 0}}}); var fe, ge = {padrões: {}, addBox: função (t, e) {t.boxes || (t.boxes = []), e. full width = e.fullWidth ||! 1 = e.position e.position || "top", e.weight = e.weight || 0 || e._layers = e._layers function () {return [{ z: 0, desenhar: função () {e.draw.apply (s, argumentos)}}]}, t.boxes.push (e)},removeBox: function (t, e) {var n = t.boxes? t.boxes.indexOf (e): - 1; -1! == n && t.boxes.splice (n, 1)}, configure: function (t , e, n) {for (var i, a = ["largura total", "posição", "peso"], r = comprimento, o = 0; o <r; ++ o) i = a [o ], n.hasOwnProperty (i) && (e [i] = n [i])}, atualização: função (t, e, n) {se (t) {var i = t.options.layout || {} , a = V.options.toPadding (i.padding), r = ea.width, o = na.height, s = função (t) {var e = função (t) {var e, n, i, a = []; para i = t [e], a.push ({índice (e = 0, n = (T || []) comprimento;; e <n ++ e.): e caixa,: i, pos : i.position, horizontal: i.isHorizontal (), weight: i.weight}); retorna a} (t), n = se (oe (e, "esquerda"),! 0), i = se (oe (e, "right")), a = S (OE (e, "top"), 0) r = se (OE (e, "bottom")); return {leftAndTop: n.concat (a) , rightAndBottom: i.concat (r), área do gráfico: OE (e, "área do gráfico"), vertical: n.concat (i), horizontal: a.concat (r)}} (t.boxes), l = s.vertical, u = s.horizontal, d = Object.freeze ({exterior largura: e, altura exterior: n, preenchimento: um, availableWidth: r, vBoxMaxWidth: r / 2 / l.length, hBoxMaxHeight: o / 2}), h = re ({maxPadding: re ({}, a), w: r, h: o, x: a.left, y: a.top}, a);! function (t, e) {var n, i ., um; para (n = 0, i = T.Length; n <i; n ++) (a = t [n]) = largura a.horizontal a.box.fullWidth && e.availableWidth: e.vBoxMaxWidth? a.height = a.horizontal && e.hBoxMaxHeight} (l.concat (u), d), He (l, h, d), He (u, h, d) && Ele (l, h, d), função (t ) {var e = t.maxPadding; função n (n) {var i = Math.max (e [n] -t [n], 0); retorna t [n] + = i, i} t.y + = n ( "topo"), T.x + = N ( "esquerda"), N ( "direito"), N ( "fundo")} (h), Ce (s.leftAndTop, h, d), h.x + = HW, H.y + = HH, CE (s.rightAndBottom, h, d), t.chartArea = {à esquerda: h.left, topo: h.top, direita: h.left + HW, inferior: h.top + hh}, V.each (s.chartArea, (função (e) {var n = e.box; re (n, t.chartArea), n.update (hw, hh)}))}}}, pe = (Fe = objecto.congelar ({__ proto __: null, padrão: "@ quadros-chave chartjs-render-animation {de {opacity: .99} a {opacity: 1}}. chartjs-render-monitor {animação: chartjs-render-animation 1ms} .chartjs monitor de -size, .chartjs-size-monitor de expandir, .chartjs-size-monitor de shrink {position: absolute; direção: ltr; restam: 0; top: 0; direita: 0; bottom: 0; overflow: hidden ; apontadora de eventos: nenhuma; visibilidade: hidden; índice z: -1} .chartjs-tamanho-monitor de expandir> div {posição: absoluto; largura: 1000000px; altura: 1000000px; esquerda: 0; topo: 0}. chartjs-size-monitor de psiquiatra> div {position: absolute; width: 200%; height: 200%; restam: 0; top: 0} "})) && fe.default || fe, me =" $ chartjs " ve = "monitor de chartjs-size" ser = "chartjs tornar monitor de" xe = "chartjs tornar animação," ye = [ "início de animação", "webkitAnimationStart"] _ e = {touchstart "mouseDown" , TouchMove "mousemove ", touchend:" mouseup ", ponteiro:" mouseenter ", ponteiro:" mousedown ", ponteiro:" mousemove ", ponteiro:" mouseup ", ponteiro:" mouseout ", ponteiro:" mouseout "}; função ke (t , e) {var n = V.getStyle (t, e), i = n && n.match (/ ^ (\ d +) (\. \ d +)? px $ /); retorna i? Number (i [1]) : void 0} var nós = !! function () {var t =! 1; tente {var e = Object.defineProperty ({}, "passivo", {get: function () {t =! 0}}); window.addEventListener ("e", null, e)} catch (t) {} return t} () && {passive :! 0}; function Me (t, e, n) {t.addEventListener (e, n, nós)} função Se (t, e, n) {t.removeEventListener (e, n, nós)} função Ce (t, e, n, i, a) {return {type: t, chart: e, native: a || nulo, x: nulo 0! == n? n: nulo, y: nulo 0! == i? i: nulo}} função Pe (t) {var e = document.createElement ("div"); retornar e.className = t || "",e} função Ae (t, e, n) {var i, a, r, o, s = t [me] || (t [me] = {}), l = s.resizer = function (t) { var e = Pe (ve), n = Pe (ve + "- expandir"), i = Pe (ve + "- encolher"); n.appendChild (Pe ()), i.appendChild (Pe ()), e. appendChild (n), e.appendChild (i), e._reset = function () {n.scrollLeft = 1e6, n.scrollTop = 1e6, i.scrollLeft = 1e6, i.scrollTop = 1e6}; var a = function ( ) {e._reset (), t ()}; retorna Me (n, "scroll", a.bind (n, "expand")), Me (i, "scroll", a.bind (i, "encolhe ")), e} ((i = function () {if (s.resizer) {var i = n.options.maintainAspectRatio && t.parentNode, a = i? i.clientWidth: 0; e (Ce (" redimensionar ", n)), i && i.clientWidth <a && && n.canvas e (Ce ( "redimensionamento", n))}}, r =! 1, função o = [] () {o = Array.prototype.slice.call (argumentos) a = a esta ||, || r (r = 0 V.requestAnimFrame.call (janela (função () {r =! 1, i.apply (a, O)})))})) ;! função (t,e) {var n = t [me] || (t [me] = {}), i = n.renderProxy = função (t) {t.animationName === xe && e ()}; V.each (ye, (função (e) {me (t, e, i)})) = !! n.reflow t.offsetParent, t.classList.add (ser)} (t, (função () {if (s.resizer ) {var e = t.parentNode; e && e! == l.parentNode && e.insertBefore (l, e.firstChild), l._reset ()}}))} função De (t) {var e = t [me] | | {}, n = e.resizer; excluir e.resizer, função (t) {var e = t [me] || {}, n = e.renderProxy; n && (V.each (ye, (function (e ) {Se (t, e, n)})), exclua e.renderProxy), t.classList.remove (be)} (t), n && n.parentNode && n.parentNode.removeChild (n)} var Te = {disableCSSInjection: ! 1, _enabled: "undefined"! = Typeof window && "undefined"! = Tipo de documento, _ensureLoaded: function (t) {if (! This.disableCSSInjection) {var e = t.getRootNode? T.getRootNode (): document; ! função (t, e) {var n = t [me] || (t [me] = {}); if (! n.containsStyles) {n.containsStyles =! 0, e = "/ * Chart.js * / \ n" + e; var i = document.createElement ("style"); i.setAttribute ("type", "text / css"), i. appendChild (document.createTextNode (e)), t.appendChild (i)}} (e.host?e:document.head,pe)konto▶,acquireContext:function(t,e)▶"string"==tipo de t ? t = document.getElementById (t): t.length && (t = t [0]), t && t.canvas && (t = t.canvas); var n = t && t.getContext && t.getContext ("2d"); return n && n. canvas === t? (this._ensureLoaded (t), função (t, e) {var n = t.style, i = t.getAttribute ("altura"), a = t.getAttribute ("width"); Se (t [mim] = {inicial: {altura: i, largura: uma, estilo: {display: n.display, altura: n.height, largura: n.width}}}, n.display = n.display || "bloco", nulo === a || "" === a) {var r = ke (t, "width"); nulo 0! == r && (t.largura = r)} if (nulo === i || "" === i) se ( "" === t.style.height) t.height = t.width / (e.options.aspectRatio || 2); else {var o = ke (t, "height"); void 0! == r && (t.height = o)}} (t, e), n): null}, releaseContext: function (t) {var e = t.canvas; if (e [me]) {var n = e [me] .inicial; ["altura", "largura"]. forEach ((função (t) {vari = n [t ?]; V.isNullOrUndef (i) e.removeAttribute (t): e.setAttribute (T i)})), V.each (n.style || {} (função (T, N) {e. style [n] = t})), e.width = e.width, exclua e [me]}}, addEventListener: function (t, e, n) {vari = t.canvas; if ("redimensionar"! == e) {var a = n [me] || (n [me] = {}); Eu (i, e, (a.proxies || (a.proxies = {})) [t.id + " _ "+ e] = função (e) {n (função (t, e) {var n = _e [t.type] || t.type, i = V.getRelativePosition (t, e); return Ce (n , e, ix, iy, t)} (e, t))})} else Ae (i, n, t)}, removeEventListener: function (t, e, n) {var i = t.canvas; if ( "redimensionar"!== e) {var a = ((n [me] || {}). proxies || {}) [t.id + "_" + e]; a && Se (i, e, a)} else De (i V.addEvent = Eu, V.removeEvent = Se; var Ie = Te._abled? Te: {adquirirContext: função (t) {retornar t && t.canvas && (t = t.canvas), t && t.getContext (" 2d ") || nulo}}, Fe = V.extend ({Inicializar: função () {}, acquireContext: função () {}, contexto de libertação: função () {} addEventListener: função () {}, removeEventListener: function () {}}, ie); z._set ("global", {plugins: {}}); var Le = {_ plugins: [], _ cacheId: 0, registre: function (t) {var e = this . ._plugins; [] concatenação (t) .forEach ((função (t) {- 1 === e.indexOf (t) && e.push (t)})), this._cacheId ++}, unregistere: função (t ) {var e = this._plugins; []. concat (t). forEach ((function (t) {var n = e.indexOf (t); - 1! == n && e.splice (n, 1)}) ) this._cacheId ++}, claro: função () {this._plugins = [], this._cacheId ++}, contar:function () {retorna this._plugins.length}, getAll: function () {retorna this._plugins}, notifica: function (t, e, n) {var i, a, r, o, s, l = this. descritores (t), u = l.length; para (i = 0; i <u; i ++) se ( "função" == typeof (s = (r = (a = l [i]) plug-in). . [e]) && ((o = [t] .concat (n || [])) empurrão (a.options),! 1 === s.apply (R, O))) retornar um retorno ;! ! 0}, descritores: function (t) {var e = t. $ Plugins || (t. $ Plugins = {}); if (e.id === this._cacheId) retorna e.descriptors; var n = [], i = [], a = t && t.config || {}, r = a.options && a.options.plugins || {}; retorne this._plugins.concat (a.plugins || []). forEach ( (função (t) {if (-1 === n.indexOf (t)) {var e = t.id, a = r [e];! 1! == a && (! 0 === a && (a = v.Clone (z.global.plugins [e])), n.push (t), i.push ({plug-in: t, opções: a || {}}}})))), e.descriptors = i, e.id = this._cacheId, i}, _ invalidate: function (t) {delete t. $ plugins}}, Oe = {constructors: {}, padrões: {}, registerScaleType: function (t,e, n) {this.constructors [t] = e, this.defaults [t] = V.clone (n)}, getScaleConstructor: function (t) {retorna this.constructors.hasOwnProperty (t)? this.constructors [ t]: void 0}, getScaleDefaults: function (t) {retorna this.defaults.hasOwnProperty (t)? V.merge ({}, [z.scale, this.defaults [t]]): {}}, updateScaleDefaults : função (T, e) {this.defaults.hasOwnProperty (t) && (this.defaults [t] = V.extend (this.defaults [t], e))}, addScalesToLayout: função (t) {V. cada (t.scales, (função (e) {e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, ge.addBox (t, e) }))}}, Re = V.valueOrDefault, ze = V.rtl.getRtlAdapter; z._set ( "globais" {dicas: {habilitado: 0, personalizados: zero, de moda: posição "mais próximo": " média "intersectam: 0, a cor de fundo:" rgba (0,0,0,0.8) "estilo de fonte título" negrito", titleSpacing: 2 título inferior margem: 6, título fonte cor:"#Fff", alinhamento título: "esquerda", bodySpacing: 2, fonte do corpo de cor: "# fff" corpo align: "esquerda", footerFontStyle: "bold", footerSpacing: 2, footerMarginTop: 6, footerFontColor "# fff" footerAlign "esquerda", ypadding: 6, xpadding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, multiKeyBackground: "# fff", exibição cores: 0, borderColor "rgba (0,0,0,0) ", borderWidth: 0, retornos de chamada: {beforeTitle: V.noop, title: function (t, e) {var n =" ", i = etiquetas e, a = i? comprimento: 0; if (t. comprimento> 0) {var r = t [0]; r.label? n = r.label: r.xLabel? n = r.xLabel: a> 0 && r.index <a && (n = i [r.index]) } return n}, afterTitle: V.noop, beforeBody: V.noop, beforeLabel: V.noop, label: função (t, e) {var n = e.datasets [t.datasetIndex] .label || ""; retornar n && (n + = ":"), V.isNullOrUndef (valor t)? n + = t.yLabel: n + = valor t, n},labelColor: função (t, e) {var n = e.getDatasetMeta (t.datasetIndex). dados [t.index] ._ visualização; retornar {borderColor: n.borderColor, backgroundColor: n.backgroundColor}}, labelTextColor: function ( ) {return this._options.bodyFontColor}, afterLabel: V.noop, afterBody: V.noop, beforeFooter: V.noop, rodapé: V.noop, afterFooter: V.noop}}}); var Ne = {average: function (t) {if (! t.length) return! 1; var e, n, i = 0, a = 0, r = 0; for (e = 0, n = t.length; e <n; + + e) {var o = t [e]; if (o && o.hasValue ()) {var s = o.tooltipPosition (); i + = sx, a + = sy, ++ r}} retornar {x: i / r , y: a / r}}, mais próximo: function (t, e) {var n, i, a, r = ex, o = ey, s = Number.POSITIVE_INFINITY; for (n = 0, i = t.length ; n <i; ++ n) {var l = t [n]; if (l && l.hasValue ()) {var u = l.getCenterPoint (), d = V.distanceBetweenPoints (e, u); d <s && (s = d, a = l)}} if (a) {var h = a.tooltipPosition (); r = hx, o = hy} retornar {x: r, y: o}}}; função Be (t , e) {return e && (V.isArray (e)? Array.prototype.push.apply (t, e): t.push (e)), t} função Ee (t) {return ("string" == tipo de t || t instância da string) && t.indexOf ("\ n" )> - 1? T.split ("\ n"): t} function We (t) {var e = z.global; return {xPadding: t.xPadding, yPadding: t.yPadding, xAlign: t.xAlign, yAlign: t.yAlign, rtl: t.rtl, TextDirection: t.textDirection, corpo font color: t.bodyFontColor, _bodyFontFamily: Re (t.bodyFontFamily, e.defaultFontFamily) _ estilo da fonte do corpo: Re (t.bodyFontStyle, e.defaultFontStyle) _bodyAlign: t.bodyAlign, corpo tamanho da fonte: Re (t.bodyFontSize, e.defaultFontSize) bodySpacing: t.bodySpacing, título fonte cor: t.titleFontColor, _titleFontFamily: Re (t.titleFontFamily, e.defaultFontFamily) _ estilo de fonte título: Re (t. título estilo de fonte, e.defaultFontStyle), o tamanho da fonte em epígrafe: Re (t.titleFontSize, e.defaultFontSize) _ título align: t.titleAlign, titleSpacing: t.titleSpacing, margem inferior do título: t.titleMarginBottom,footerFontColor: t.footerFontColor, _footerFontFamily: Re (t.footerFontFamily, e.defaultFontFamily) _ footerFontStyle: Re (t.footerFontStyle, e.defaultFontStyle) footerFontSize: Re (t.footerFontSize, e.defaultFontSize) _ footerAlign: t.footerAlign , footerSpacing: t.footerSpacing, footerMarginTop: t.footerMarginTop, caretSize: t.caretSize, raio de canto: t.cornerRadius, cor de fundo: t.backgroundColor, opacidade: 0, lenda cor de fundo: t.multiKeyBackground, exibir cores: t.displayColors, cor da borda: t .borderColor, borderWidth: t.borderWidth}} função Ve (t, e) {return "center" === e? t.x + t.width / 2: "right" === e? t.x + t .width-t.xPadding: t.x + t.xPadding} função He (t) {retornar Be ([], Ee (t))} var je = X.extend ({initialize: function () {this._model = Nós (this._options), this._lastActive = []}, getTitle: function () {var t = isto, e = t._options, n = e.callbacks, i = n.beforeTitle.apply (t, argumentos ), a = n.title.apply (t, argumentos), r = n.afterTitle.apply (t, argumentos), o = []; return o = Be (o, Ee (i)), o = Be (o, Ee (a) ), o = Be (o, Ee (r))}, getBeforeBody: function () {retorna He (this._options.callbacks.beforeBody.apply (this, argumentos))}, getBody: function (t, e) { var n = isto, i = n._options.callbacks, a = []; retorna V.each (t, (função (t) {var r = {antes: [], linhas: [], depois: []}) ; Seja (r.before, Ee (i.beforeLabel.call (n, T, s))), ser (r.lines, i.label.call (n, t, e)), ser (r.after, Ee (i.afterLabel.call (n, t, e))), a.push (r)})), a}, getAfterBody: function () {return He (this._options.callbacks.afterBody.apply (this , argumentos))}, getFooter: function () {var t = isto, e = t._options.callbacks, n = e.beforeFooter.apply (t, argumentos), i = e.footer.apply (t, argumentos) , a = e.afterFooter.apply (t, argumentos), r = []; return r = Be (r, Ee (n)), r = Be (r, Ee (i)), r = Be (r, Ee (a))}, update: function (t) {var e, n, i, a, r, o, s, l, u, d, h = isto, c = h._options, f = h._model , g = h._model = Nós (c),p = h._active, m = h._data, v = {xalign: f.xAlign, yAlign: f.yAlign}, b = {x: fx, y: pt}, x = {largura: f.width, altura : f.height}, y = {x: f.caretX, y: f.caretY}; if (comprimento de página) {g.opacidade = 1; var _ = [], k = []; y = Ne [ c.position] .call (h, p, h.eventPosition); var w = []; for (e = 0, n = comprimento de p; e <n; ++ e) w.push ((i = p [e], a = vazio 0, r = vazio 0, o = vazio 0, s = vazio 0, l = vazio 0, u = vazio 0, d = vazio 0, a = i._xScale, r = i._yScale || i._scale, o = i._index, s = i._datasetIndex, l = i._chart.getDatasetMeta (s) .Controller, u = l._getIndexScale (), d = l._getValueScale () {xlabel: um a.getLabelForIndex (O, S): "" ylabel: r r.getLabelForIndex (O, S): "" etiqueta: u "" + u.getLabelForIndex (O, S): "", valor ?: D "" + d.getLabelForIndex (O, s): "", índice: o, datasetIndex: s, x: i._model.x, y: i._model.y})); c.filter && (w = w.filter ((função (t) {retornar c.filter (t, m)}))), c.itemSort && (w = w.sort ((função (t,e) {return c.itemSort (t, e, m)}))), V.each (w, (function (t) {_. push (c.callbacks.labelColor.call (h, t, h._chart )), k.push (c.callbacks.labelTextColor.call (h, t, h._chart))})) = g.title h.getTitle (W, m), g.beforeBody h.getBeforeBody = (w , m), g.body h.getBody = (W, m), g.afterBody h.getAfterBody = (W, m), g.footer h.getFooter = (W, m), gx = yx, yy = gy , g.caretPadding = c.caretPadding, g.labelColors = _, g.labelTextColors = k, g.dataPoints = w, x = função (t, e) {var n = t._chart.ctx, i = 2 * e .yPadding, a = 0, r = e.body, o = r.reduce ((função (t, e) {return t + e.before.length + e.lines.length + e.after.length}), 0); o + = e.beforeBody.length + e.afterBody.length; var s = e.title.length, l = e.footer.length, u = e.titleFontSize, d = e.bodyFontSize, h = e. ? footerFontSize; i + = s * U, i + = s (s-1) * e.titleSpacing: 0, i + = s e.titleMarginBottom: 0, i + = o * d, i + = O (O-1) *? e.bodySpacing: 0, i + = l? e.footerMarginTop: 0, i + = l * h, i + = l? (l-1) * e.footerSpacing: 0; var c = 0,f = function (t) {a = Math.max (a, n.measureText (t) .width + c)}; return n.font = V.fontString (u, e._titleFontStyle, e._titleFontFamily), V. cada (e.title, f) = n.font V.fontString (d, e._bodyFontStyle, e._bodyFontFamily) V.each (e.beforeBody.concat (e.afterBody), f), c = e. exibição cores d + 2? 0, V.each (r, (função (t) {V.each (t.before, f), V.each (t.lines, f), V.each (t.after, f)})), c = 0, n.font V.fontString = (h, e._footerFontStyle, e._footerFontFamily) V.each (e.footer, f), {largura: a + = 2 * e.xPadding , height: i}} (este, g), b = função (t, e, n, i) {var a = tx, r = ty, o = t.caretSize, s = t.caretPadding, l = t. cornerRadius, u = n.xAlign, d = n.yAlign, h = O + s, c = l + s; retorno "direita" === L = a- e.width: "centro" u === && (? (a- = e.width / 2) + e.width> i.width && (a = i.width-e.width), uma <0 && (a = 0)), "topo" === d? r + = h r - = "inferior" === d e.height + H: e.height / 2 "centro" === d "esquerda"?=== u a + = h "Right" === u && (a- = h):? "Esquerda" === u a- = c: "certo" === u && (a + c =) { x: a, y: r}} (g, x, v = função (t, e) {var n, i, a, r, o, s = t._model, l = t._chart, u = t. _chart.chartArea, d = "centro", h = "centro"; sy <altura e altura? h = "parte superior": sy> altura e altura e& (h = "parte inferior"); var c = (u .left + u.right) / 2, f = (u.top + u.bottom) / 2; "center" === h? (n = função (t) {retorna t <= c}, i = função (t) {return t> c}) :( n = função (t) {return t <= largura e / / 2}, i = função (t) {retorno t> = largura e largura / / 2 }), a = function (t) {return t + e.width + s.caretSize + s.caretPadding> l.width}, r = function (t) {return te.width-s.caretSize-s.caretPadding < 0}, o = função (t) {retornar t <= f? "Superior": "inferior"}, n (sx)? (D = "esquerda", a (sx) && (d = "centro", h = o (sy))): i (sx) && (d = "direita", r (sx) && (d = "centro", h = o (sy))); var g = t._options; return {xAlinhamento: g.xAlinhamento? g.xAlinhamento: d, yAlinhamento: g.yAlinhamento? g .yAlign: h}} (this, x), h._chart)} else g.opacity = 0; return g.xAlign = v.xAlign, g.yAlign = v.yAlign, gx = bx, gy = by, g .width = x.width, g.height = x.height, g.caretX = yx, yy = g.caretY, h._model = g, T && && c.custom c.custom.call (h, g), h}, drawCaret () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () .lineTo (a.x2, a.y2), n.lineTo (a.x3, a.y3)}, getCaretPosition: function (t, e, n) {var i, a, r, o, s, l, u = n.caretSize, d = n.cornerRadius, h = n.xAlign, c = n.yAlign, f = tx, ty = g, p = e.width, m = e.height; se ( "centro" = == c) s = g + m / 2, "esquerda" === h? (a = (i = f) -u, R = i, o = s + u, l = su) :( a = ( i = f + p) + u, r = i, o = su, l = s + u); caso contrário, se ("left" === h? (i = (a = f + d + u) -u, r = a + U)? "direita" === h (i = (a = f + PDU) -u, r = a + u) :( i = (a = n.caretX) -u,r = a + u), "top" === c) s = (o = g) -u, l = o; senão {s = (o = g + m) + u, l = o; var v = r; r = i, i = v} retorno {i x1, x2: um, x3: r, y1: O, y2: s, y3: l}}, drawTitle: função (t, s, N) {var i, a, r, o = e.title, s = o.length; if (s) {var l = ze (e.rtl, ex, e.width); for (tx = Ve (e, e._titleAlign) ) n.textAlign = l.textAlign (e._titleAlign) n.textBaseline = "meio", i = e.titleFontSize, a = e.titleSpacing, n.fillStyle = e.titleFontColor, n.font = V.fontString (i, e._titleFontStyle, e._titleFontFamily), r = 0; R <s; r ++) n.fillText (O [R] lx (TX), t.y + i / 2) + t.y = i + a, r + 1 === s && (t.y + = e.titleMarginBottom-a)}}, drawBody: function (t, e, n) {var i, a, r, o, s, l, u, d, H = e.bodyFontSize, c = e.bodySpacing, f = e._bodyAlign, g = e.body, p = e.displayColors, m = 0, v = p? Ve (e, "esquerda") : 0, b = ze (e.rtl, ex, e.width), x = função (e) {n.fillText (s, bx (T.x + m), t.y + h / 2), t .Y + = H + c}, y = b.textAlign (f); para (n.textAlign = f, n.textBaseline = "meio", n.font = V.corda da fonte (h, e._bodyFontStyle, e._bodyFontFamily) tx = Ve (e, y) = n.fillStyle e.bodyFontColor, V.each (e.beforeBody, x), m = p && "direita" == ? y "centro" === f h / 2 + 1: H + 2: 0, s = 0, U = g.length; s <u; s ++) {for (i = g [s], a = e.labelTextColors [s], R = e.labelColors [s], n.fillStyle = a, V.each (i.before, x), l = 0, d = .length (o = i.lines) ; l <d; ++ l) {if (p) {var _ = bx (v); n.fillStyle = e.legendColorBackground, n.fillRect (b.leftForLtr (_, h), ty, h, h) , n.lineWidth = 1, = n.strokeStyle r.borderColor, n.strokeRect (b.leftForLtr (_, h), ty, H, H), n.fillStyle = r.backgroundColor, n.fillRect (b.leftForLtr (b.xPlus (_, 1), H-2), t.y + 1, H-2, H-2), n.fillStyle = a} x (o [l])} V.each (i. depois, x)} m = 0, V.each (e.afterBody, x), ty- = c}, drawFooter: function (t, e, n) {var i, a, r = e.footer, o = r.length; if (o) {var s = ze (e.rtl, ex, e.width); for (tx = Ve (e, e._footerAlign), t.y + = e.footerMarginTop, n.textAlign = s.textAlign (e._footerAlign), n.TextBaseline = "meio", i = e.footerFontSize, n.fillStyle = e.footerFontColor, n.font = V.fontString (i, e._footerFontStyle, e._footerFontFamily), a = 0; a ++; um <o ) n.fillText (R [a], sx (TX), t.y + i / 2), t.y = + i + e.footerSpacing}}, DrawBackground: função (t, s, n, i) {n .fillStyle = e.backgroundColor, n.strokeStyle = e.borderColor, n.lineWidth = e.borderWidth; var a = e.xAlign, r = e.yAlign, o = tx, s = ty, l = i.width, u = i.height, d = e.cornerRadius; n.beginPath () n.moveTo (O + d, s), "topo" r === && this.drawCaret (t, i), n.lineTo (O + ld, s), n.quadraticCurveTo (O + L, S, O + l, s + d), "centro" r === && "direita" uma === && this.drawCaret (t, i), n.lineTo ( O + l, s + UD), n.quadraticCurveTo (O + l s + U + O ld, s + u), "inferior" r === && this.drawCaret (t, i), n.lineTo (O + d, s + u), n.quadraticCurveTo (O, s + L, O, s + UD), "centro" r === && "esquerda" === um && este.drawCaret (t, i), n.lineTo (O, S + d), n.quadraticCurveTo (O, S, S + d, s), n.closePath () n.fill () e.borderWidth> 0 && n .stroke ()}, draw: function () {var t = this._chart.ctx, e = this._view; if (0! == e.opacity) {var n = {width: largura e largura, altura: e.height} i = {x, y: ex: ey}, um = Math.abs (e.opacity <0,001) 0: e.opacity, r = || e.title.length e.beforeBody. comprimento || || || e.body.length e.afterBody.length e.footer.length; this._options.enabled && && r (t.save () = t.globalAlpha um, this.drawBackground (i, e, T , n), i.y + = e.yPadding, V.rtl.overrideTextDirection (t, e.textDirection) this.drawTitle (i, e, T), this.drawBody (i, e, T), this.drawFooter (i, e, t), V.rtl.restoreTextDirection (t, e.textDirection), t.restore ())}}, handleEvent: function (t) {var e, n = isto, i = n._ opções; retornar n._lastActive = n._lastActive || [], "mouseout" === t.type? n._active = [] :( n._active = n._chart.getElementsAtEventForMode (t, i.mode, i), i.inverter && n._active.reverse ()), (e =! V.arrayEquals (n._active, n._lastActive)) && (n._lastActive = n._active, (i.enabled || i.custom) && (n. _eventPosition = {x: tx, y: ty}, n.update (! 0), n.pivot ())), e}}), qe = Ne, Ue = je; Ue.positioners = qe; var Ye = V.valueOrDefault; function Ge () {retorna V.merge ({}, []. Slice.call (argumentos), {fusão: função (t, e, n, i) {) (if ("xAxes" === || "yAxes" === t) {var a, r, o, s = n [t] .length; para (e [t] || (e [t] = []), a = 0; a <s; ++ a) o = n [t] [a], r = Ye (o.type, "xAxes" === t "categoria": "linear"), um?> = e [t]. comprimento && e [t] .push ({}),! e [o] [a] .type || o.type && o.type == s [t] [a] .type? V.merge (e! [t] [ a], [Oe.getScaleDefaults (r), o]): V.merge (e [t] [a], o)} else V._merger (t, e, n, i)}})} função Xe ( ) {return V.merge ({}, []. slice.call (argumentos), {fusão: função (t, e, n, i) {var a = e [t] || {}, r = n [ t]; "escalas"=== T E [t] = Ge (a, r) ​​"Scale" === T E [t] = V.merge (a, [Oe.getScaleDefaults (R.TYPE), r])?: V._merger (t, e, n, i)}})} função Ke (t) {var e = t.options; V.each (t.scales, (function (e) {ge.removeBox (t, e )})), e = Xe (z.global, z [t.config.type], e), t.options = t.config.options = e, t.ensureScalesHaveIDs () (t.buildOrUpdateScales), t .tooltip._options = e.tooltips, t.tooltip.initialize ()} função Ze (t, e, n) {vari, a = função (t) {return t.id === i}; faça {i = e + n ++} while (V.findIndex (t, a)> = 0); return i} função $ e (t) {return "top" === t || "bottom" === t} função Je (t, e) {função de retorno (n, i) {retorno n [t] === i [t]? n [e] -i [e]: n [t] -i [t]}} z. _set ( "globais" {elementos: {}, eventos: [ "movimento do mouse", "mouseout", "clique", "start toque", "toque move"], hover {onHover: zero, moda: se cruzam "mais próximo" : 0, animationDuration: 400}, onClick: null,keepAspectRatio :! 0, responsivo :! 0, responsiveAnimationDuration: 0}); var Qe = função (t, e) {retorna this.construct (t, e), this}; V.extend (Qe.prototype, {construct: função (t, e) {var n = isto; e = função (t) {var e = (t = t || {}). dados = t.data || {}; return e.datasets = e.datasets || [] = e.labels e.labels || [] t.options = Xe (z.global, z [t.type] t.options || {})} t (s); var I = Fe.acquireContext (t, e), a = i && i.canvas, R = um && a.height, o = um && a.width; n.id V.uid = () i = n.ctx, n.canvas = um , n.config = e, n.width = O, R = n.height, n.aspectRatio = r o / r :? nulos n.options = e.options, n._bufferedRender = 1, = n._layers [], n.chart = n, n.controller = n, Qe.instances [n.id] = n, Object.defineProperty (n, "dados", {get: function () {return n.config.data} , set: function (t) {n.config.data = t}}), i && a? (n.initialize (), n.update ()): console.error ("Falha ao criar gráfico: pode"t adquira contexto do item especificado ")}, inicialize: function () {var t = this; retorne Le.notify (t," beforeInit "), V.retinaScale (t, t.options.devicePixelRatio), t.bindEvents (), t.options.responsive && t.resize (! 0), t.initToolTip (), Le.notify (t, "afterInit"), t}, clear: function () {retorna V.canvas.clear (this) , this}, stop: function () {return $ .cancelAnimation (this), this}, redimensione: function (t) {var e = this, n = e.options, i = e.canvas, a = n.maintainAspectRatio && e .aspectRatio || zero, r = Math.max (0, Math.floor (V.getMaximumWidth (i))), o = Math.max (0, Math.floor (a r / a: V.getMaximumHeight (i ))) ;? if (! (e.width == r || e.height == o) && (i.width = e.width = r = i.height e.height = o, i.style. width = r + "px", i.style.height = o + "px", V.retinaScale (e, n.devicePixelRatio),! t)) {var s = {width: r, height: o}; Le.notify (e "redimensionamento," [s]) n, n.onResize &&.onResize (e, s), e.stop (), e.update ({duration: n.responsiveAnimationDuration})}}, assegureScalesHaveIDs: function () {var t = this.options, e = t.scales || {} , n = t.scale; V.each (e.xAxes, (função (T, N) {t.id || (t.id = Ze (e.xAxes, "X-eixo -', n))} )), V.each (e.yAxes, (função (T, N) {t.id || (t.id = Zé (e.yAxes ", eixo y -', n))})), n && (n.id = n.id || "escala")}, buildOrUpdateScales: function () {var t = isto, e = opções.n = t.scales || {}, i = [], a = Object.keys (n) .reduce ((function (t, e) {return t [e] =! 1, t}), {}); e.scales && (i = i.concat ((e.scales.xAxes || []) mapa ((function (t) {return {opções: t, DTYPE: "categoria", dposition: "bottom"}}).), (e.scales.yAxes || []) mapa (. (function (t) {return {opções: t, DTYPE: "lineares", dposition: "esquerda"}})))) && e.scale i.push ({opções: e.scale, dtipo: "linear radial" isDefault : 0, dposition: "chartArea "}), V.each (i, (função (e) {vari = e.options, r = i.id, o = Ye (i.type, e.dtype); $ e (i.position) ! == $ e (e.dposition) && (i.position = e.dposition), a [r] =! 0; var s = null; if (r em n && n [r] .type === o) ( s = n [r]). options = i, s.ctx = t.ctx, s.chart = t; else {var l = Oe.getScaleConstructor (o); if (! l) return; s = new l ( {ID: r, tipo: o, opções: i, CTX: t.ctx, carta: t}), N [s.id] = s} s.mergeTicksOptions () && e.isDefault (t.scale = s) })), V.each (a, (função (t, e) {t || excluir n [e]})), t.scales = n, Oe.addScalesToLayout (this)}, buildOrUpdateControllers: function () { var t, e, n = isto, i = [], a = n.data.datasets; para (t = 0, e = comprimento.a; t <e; t ++) {var r = a [t], o = n.getDatasetMeta (t), s = || R.TYPE n.config.type; se (o.type && o.type == s && (n.destroyDatasetMeta (t), o = n.getDatasetMeta (t))! o.type = s, = o.order r.order || 0, o.index = t, o.controller) o.controller.updateIndex (t), o.controller.linkScales ();else {var l = $ t [o.type]; if (void 0 === l) lança novo erro ('"' + o.type + '" não é um tipo de gráfico.'); o.controller = new l (n, t), i.push (o.controller)}} retorne i}, resetElements: function () {var t = this; V.each (t.data.datasets, (function (e, n) {t .getDatasetMeta (n) .controller.reset ()}), t)}, redefinir: function () {this.resetElements (), this.tooltip.initialize ()}, atualizar: function (t) {var e, n , i = this; if (t && "objeto" == tipo de t || (t = {duração: t, preguiçoso: argumentos [1]}), Ke (i), Le._invalidate (i),! 1! = = Le.notify (i, "beforeUpdate")) {i.tooltip._data = i.data; var a = i.buildOrUpdateControllers (); for (e = 0, n = i.data.datasets.length; e < n; e ++) i.getDatasetMeta (e) .controller.buildOrUpdateElements (); i.updateLayout) i.options.animation && && i.options.animation.duration V.each (a, (função ((t) {t.reset () })) i.updateDatasets () i.tooltip.initialize (), i.carregar = activas [], Le.notify (i, "após update"), i._layers.sort (Je ( "z", "_ idx")), i._bufferedRender i._bufferedRequest = {duração: t.duration, facilitando : t.easing, preguiçoso: t.lazy}: i.render (t)}}, updateLayout: function () {var t = this ;! 1! == Le.notify (t, "beforeLayout") && (ge .Update (isto, this.width, This.Height) t._layers = [], V.each (t.boxes, (função (e) {e._configure && e._configure () t._layers.push.apply (t._layers, e._layers ())}), t), t._layers.forEach ((função (T, e) {e} = t._idx)), Le.notify (t, "depois de actualização de escala") , Le.notify (t, "afterLayout"))}, updateDatasets: function () {if (! 1! == Le.notify (isto, "beforeDatasetsUpdate"))) {for (var t = 0, e = this. data.datasets.length; t <e; ++ t) this.updateDataset (t); Le.notify (this, "afterDatasetsUpdate")}}, updateDataset: function (t) {var e = this.getDatasetMeta (t) , n = {meta: e,index: t}; 1 == Le.notify (this, "antes da data de configuração de dados," [n]) && (e.controller._update () Le.notify (isto "após a data de configuração de dados," [n]))}! , render: function (t) {var e = this; t && "objeto" == tipo de t || (t = {duração: t, preguiçoso: argumentos [1]}); var n = e.options.animation, i = Ye (duração t, n && n.duração), a = tempo preguiçoso; if (! 1! == Le.notify (e, "beforeRender")) {var r = function (t) {Le.notify (e , "afterRender"), V.callback (n && n.onComplete, [t], e)}; if (n && i) {var o = new Z ({numSteps: i / 16.66, easing: t.easing || n.easing , render: function (t, e) {var n = V.easing.effects [e.easing], i = e.currentStep, a = i / e.numSteps; t.draw (n (a), a, i )}, onAnimationProgress: n.onProgress, onAnimationComplete: r}); $. addAnimation (e, o, i, a)} else e.draw (), r (novo Z ({numSteps: 0, chart: e}) ); return e}}, desenhe: function (t) {var e, n, i = this; if (i.clear (), V.isNullOrUndef (t) && (T = 1), i.transition (t)! (I.width <= 0 || i.height <= 0) &&! 1! == Le.notify (i, "beforeDraw" [t] )) {for (n = i._layers, e = 0; e <n.length && n [e] .z <= 0; ++ e) n [e] .draw (i.chartArea); para (i.drawDatasets (t); e <n.length; ++ e) n [e] .draw (i.chartArea); i._drawTooltip (t), Le.notify (i, "afterDraw," [T])}}, transição: função (t) {para (var e = 0, n = (this.data.datasets || []). length; e <n; ++ e) this.isDatasetVisible (e) && this.getDatasetMeta (e) .controller.transition (t); this.tooltip.transition (t)}, _ getSortedDatasetMetas: function (t) {var e, n, i = []; for (e = 0, n = (this.data.datasets | | []). length; e <n; ++ e) t &&! this.isDatasetVisible (e) || i.push (this.getDatasetMeta (e)); return i.sort (Je ("order", "index ")), i}, _ getSortedVisibleDatasetMetas: function () {retorna this._getSortedDatasetMetas (! 0)}, drawDatasets: function (t) {var e, n; if (! 1!. == Le.notify (isto, "beforeDatasetsDraw," [T])) {for (n = (e = this._getSortedVisibleDatasetMetas ()) comprimento-1; n> = 0 - N) this.drawDataset (e [n], t); Le.notify (this, "afterDatasetsDraw", [t])}}, drawDataset: function (t, e) {var n = {meta: t, índice: t.index, easingValue: e };! 1 == Le.notify (this, "beforeDatasetDraw" [n]) && (t.controller.draw (e), Le.notify (this, "afterDatasetDraw" [n]))} _ drawTooltip : function (t) {var e = this.tooltip, n = {tooltip: e, easingValue: t};! 1! == Le.notify (este, "beforeTooltipDraw", [n]) && (e.draw ( ), Le.notify (this, "afterTooltipDraw", [n]))}, getElementAtEvent: function (t) {retorne ae.modes.single (this, t)}, getElementsAtEvent: function (t) {retorne ae.modes .label (this, t, {intersect :! 0})}, getElementsAtXAxis: function (t) {return ae.modes ["x-axis"] (this, t, {intersect :! 0})}, getElementsAtEventForMode:function (t, e, n) {var i = ae.modes [e]; return "function" == typeof i? i (this, t, n): []}, getDatasetAtEvent: function (t) {return ae .modes.dataset (isso, t, {intercepta :! 0})}, getDatasetMeta: função (t) {var e = this.data.datasets [t]; e._meta || (e._meta = {}) ; var n = e._meta [this.id]; return n || (n = e._meta [this.id] = {tipo: nulo, dados: [], conjunto de dados: nulo, controlador: nulo, oculto: nulo , xAxisID: nulo, yAxisID: nulo, ordem: e.order || 0, índice: t}), n}, getVisibleDatasetCount: function () {for (var t = 0, e = 0, n = this.data. datasets.length; e <n; ++ e) this.isDatasetVisible (e) && t ++; return t}, isDatasetVisible: function (t) {var e = this.getDatasetMeta (t); return "boolean" == typeof e. oculto ?! e.hidden :! this.data.datasets [t] .hidden}, generateLegend: function () {retorna this.options.legendCallback (this)}, destroyDatasetMeta: function (t) {var e = this.id , n = this.data.datasets [t], i = n._meta && n._meta [e];i && (i.controller.destroy (), exclua n._meta [e])}, destrua: function () {var t, e, n = isto, i = n.canvas; for (n.stop (), t = 0, e = n.data.datasets.length; t <e; T ++) n.destroyDatasetMeta (t); i && (n.unbindEvents () V.canvas.clear (s), Fe.releaseContext (n .ctx), n.canvas = nulo, n.ctx = nulo), Le.notify (n, "destroy"), exclua Qe.instances [n.id]} para toBase64Image: function () {retorne this.canvas. toDataURL.apply (this.canvas, argumentos)}, initToolTip: function () {var t = this; t.tooltip = new Ue ({_ chart: t, _chartInstance: t, _data: t.data, _options: t.options .tooltips}, t)}, bindEvents: function () {var t = this, e = t._listeners = {}, n = function () {t.eventHandler.apply (t, argumentos)}; V.each ( t.options.events, (função de (i) {Fe.addEventListener (t, i, n), e [i] = n})), t.options.responsive && (n = função () {t.resize () } Fe.addEventListener (t, "redimensionamento", n), n = e.resize)}, unbindEvents:function () {var t = this, e = t._listeners; e && (excluir t._listeners, V.each (e, (function (e, n) {Fe.removeEventListener (t, n, e)}))) }, updateHoverStyle: function (t, e, n) {var i, a, r, o = n? "set": "remove"; for (a = 0, r = comprimento de t; a <r; ++ a) (i = t [a]) && this.getDatasetMeta (i._datasetIndex) .Controller [O + "HoverStyle"] (i); "conjunto de dados" e === && this.getDatasetMeta (t [0] ._ datasetIndex) .Controller [ "_" + o + "DatasetHoverStyle"] ()}, eventHandler: function (t) {var e = this, n = e.tooltip; if (! 1! == Le.notify (e, "beforeEvent", [t ])) {e._bufferedRender =! 0, e._bufferedRequest = null; var i = e.handleEvent (t); n && (i = n._start? n.handleEvent (t): i | n.handleEvent (t) ), Le.notify (e, "afterEvent", [t]); var a = e._bufferedRequest; retorna um? E.render (a): i &&! E.animating && (e.stop (), e.render ( {duração: e.options.hover.animationDuration, lento :! 0})), e._bufferedRender =! 1, e._bufferedRequest = null, e}}, handleEvent: function (t) {var e, n = isto, i = n.options || {} , a = i.hover; return n.lastActive = n.lastActive || [], "mouseout" === t.type? n.active = []: n.active = n.getElementsAtEventForMode (t, a.mode a), V.callback (i.onHover || i.hover.onHover, [t.native, n.active], n), "mouseup"! == t.type && "clique"! == t.type || i.onClick && i.onClick.call (n, t.native, n.active) n.lastActive.length && n.updateHoverStyle (n.lastActive, A.MODE ,! 1) n.active.length && && A.MODE n.updateHoverStyle (n.active, A.MODE, 0!), e = V.arrayEquals (n.active, n.lastActive) n.lastActive = n.active, e}}), Qe.instances = {} var ;! tn = Qe; Qe.Controller = Qe, Qe.types = {}, V.configMerge = Xe, V.scaleMerge = Ge; function en () {throw new Error ("Este método não está implementado:nenhum adaptador pode ser encontrado ou uma integração incompleta foi fornecida. ")} função nn (t) {this.options = t || {}} V.extend (nn.prototype, {formatos: en, parse: en, format : en, add: en, diff: en, startOf: en, endOf: en, _criar: função (t) {retornar t}}), nn.override = função (t) {V.extend (nn.prototype, t )}; var an = {_ date: nn}, rn = {formatadores: {values: function (t) {return V.isArray (t)? t: "" + t}, linear: function (t, e, n ) {var i = n.length> 3? n [2] -n [1]: n [1] -n [0]; Math.abs (i)> 1 && t! == Math.floor (t) && ( i = t-Math.floor (t)); var a = V.log10 (Math.abs (i)), r = ""; if (0! == t) if (Math.max (Math.abs ( n [0]), Math.abs (n [n.length-1])) <1e-4) {var o = V.log10 (Math.abs (t)), s = Math.floor (o) - Math.floor (a); s = Math.max (Math.min (s, 20), 0), r = t.paraExponencial (s)} else {var l = -1 * Math.floor (a); l = Math.max (Math.min (l, 20), 0), r = t.toFixed (l)} else r = "0"; retorna r}, logarítmica: function (t, e,n) {var i = t / Math.pow (10, Math.floor (V.log10 (t))); return 0 === t? "0": 1 === i || 2 === i || || 5 === i 0 === === e || e n.length-1 t.toExponential (?): ""}}}, em = V.isArray, sn = V.isNullOrUndef, ln = V.valueOrDefault, un = V.valueAtIndexOrDefault; função dn (t, e, n) {var i, a = t.getTicks (). length, r = Math.min (e, a-1), o = t.getPixelForTick (r), s = t._startPixel, l = t._endPixel; if ((n && (i = 1 === um Math.max (OS eis) :? 0 === e (t? .getPixelForTick (1) -O) / 2: (ot.getPixelForTick (r-1)) / 2, (O + = r <e i: -i) <s-1e-6 || O> L + 1e 6))) return o} function hn (t, e, n, i) {var a, r, o, s, l, u, d, h, c, f, g, p, m, v = n. comprimento, b = [], x = [], y = []; para (a = 0, um <v; ++ a) {if (n s = [a] .label, l = n [a]. e.major principais: e.minor, t.font = u = l.string, d = i [u] = i [u] || {dados: {}, GC: []}, h = l.lineHeight , c = f = 0, Sn (s) || uma (s)) {if (uma (s)) para (r = 0, o = s.length; r <o; r ++) g = s [ r], sn (g) || em (g) || (c = V.measureText (t, d.data, d.gc, c, g), f + = h)} else c = V.measureText (t , d.data,d.gc, c, s), f = h; b.push (c), x.push (f), y.push (h / 2)} função _ (t) {return {width: b [t] || 0, altura: x [t] || 0, deslocamento: y [t] || 0}} função de retorno (t, e) {V.each (t, (função (t) {var n, i = t.gc, a = i.length / 2; if (a> e) {for (n = 0; n <a; ++ n) exclua t.data [i [n]]; i.splice (0, a)}}))} (i, v), p = b.indexOf (Math.max.apply (nula, b)), m = x.indexOf (Math.max.apply (null, x)), { primeiro: _ (0), último: _ (v-1), mais amplo: _ (p), mais alto: _ (m)}} função cn (t) {retorno t.drawTicks? t.tickMarkLength: 0} função fn (t) {var e, n; return t.display? (e = V.options._parseFont (t), n = V.options.toPadding (t.padding), e.lineHeight + n.height): 0} função gn (t, e) {retornar V.extend (V.options._parseFont ({fontFamily: ln (e.fontFamily, t.fontFamily), fontSize: ln (e.fontSize, t.fontSize), fontStyle: ln ( e.fontStyle, t.fontStyle), a altura da linha: ln (e.lineHeight, t.lineHeight)}) {cor: V.options.resolve ([e.fontColor, t.fontColor, z.global.defaultFontColor])})} função pn (t) {var e = gn (t, t.minor); return {minor: e, major: t.major.enabled? gn (t, t.major): e}} função mn (t) {var e, n, i, a = []; para (n = 0, i = comprimento t; n <i; ++ n) nulo 0! == (e = t [n] ) ._ index && a.push (e); retorna uma função} vn (t, e, n, i) {var a, r, o, s, l = ln (n, 0), u = Math.min (ln ( i, T.Length) T.Length), d = 0; para (e = Math.ceil (e), i && (e = (a = In) /Math.floor (a / s)), s = l ; s <0) d ++, s = Math.round (l + d * e); para (r = Math.max (l, 0); r <u; r ++) o = t [R], R == = s? (o._index = r, d ++, s = Math.round (l + d * e)): excluir o.label} z._set ("scale", {display :! 0, posição: "left" , offset: 1, linhas de grade: {display: 0, cor: "rgba (0,0,0,0.1)", largura de linha: 1, drawBorder: 0, drawOnChartArea: 0, drawTicks: 0, tickMarkLength: 10, linha zero largura: 1, a cor da linha de zero: "rgba (0,0,0,0.25)" zeroLineBorderDash: 0 linhas de grade, offset:: [] zeroLineBorderDashOffset 1, borderDash: [] borderDashOffset:0}, etiqueta escala: {display: 1, corda rótulo: "" padding: {superior: 4, bottom: 4}}, carrapatos: {beginAtZero: 1, minRotation: 0, maxRotation: 50, espelho: 1, padding: 0, reverse :! 1, display :! 0, autoSkip :! 0, autoSkipPadding: 0, labelOffset: 0, callback: rn.formatters.values, secundário: {}, principal: {}}}); var bn = X.extend ({zero, lineIndex: 0, getPadding: function () {return {esquerda: this.paddingLeft || 0, top: this.paddingTop || 0, direita: this.paddingRight || 0, bottom: this.paddingBottom || 0}}, getTicks: function () {retorna this._ticks}, _ getLabels: function () {var t = this.chart.data; retorna this.options.labels || (this.isHorizontal ()? T. xLabels: t.yLabels) || || t.labels []}, mergeTicksOptions: function () {}, antes de atualização: function () {V.callback (this.options.beforeUpdate, [este])}, atualização: função (t, e, n) {var i, a, r, o, s, l = this, u = l.options.ticks, d = u.sampleSize; if (l.beforeUpdate (), l.maxWidth = t , l.maxHeight = e, l.margins = V.extend ({restam: 0, direita:0, topo: 0, inferior: 0}, n), l._ticks = nulo, l.ticks = nulo, l._labelSizes = nulo, l._maxLabelLines = 0, l.longestLabelWidth = 0, l.longestTextCache = l. longestTextCache || {}, l._gridLineItems = nulo, l._labelItems = nulo, l.beforeSetDimensions () l.setDimensions () l.afterSetDimensions () l.beforeDataLimits () l.determineDataLimits () l. depois de os limites de dados () l.beforeBuildTicks (), o = l.buildTicks () || [] (! (O = l.afterBuildTicks (O) || O) ||! o.length) && l.ticks) para ( o = [], i = 0, a = l.ticks.length; i <a; ++ i) o.push ({valor: l.ticks [i], principal :! 1}); retorne l._ticks = o, s = d <comprimento, r = l._convertTicksToLabels (função s? (t, e) {para (var n = [], i = comprimento / e, a = 0, r = t. comprimento; a <r; a + = i) n.push (t [Math.floor (a)]); return n} (o, d): o), l._configure (), l.beforeCalculateTickRotation (), l .calculateTickRotation () l.afterCalculateTickRotation () l.beforeFit () l.fit () l.afterFit () && u.display l._ticksToDraw = (u.AUTOSKIP || "auto" === u.source) l._autoSkip (o): O, S && (r = l._convertTicksToLabels (l._ticksToDraw)), l.ticks = r, l.afterUpdate () l? .minSize}, _ configure: function () {var t, e, n = this, i = n.options.ticks.reverse; n.isHorizontal ()? (t = n.left, e = n.right) :( t = n.top, e = n.bottom, i = i), n._startPixel = t, n._endPixel = e, i = n._reversePixels, n._length et =}, depois de actualização: função () {V .callback (this.options.afterUpdate, [this])}, beforeSetDimensions: function () {V.callback (this.options.beforeSetDimensions, [this])}, setDimensions: function () {var t = this; t. isHorizontal ()? (t.width = t.maxWidth, t.left = 0, = t.right t.width) :( t.height = t.maxHeight, t.top = 0, = t.bottom t.height ) t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0}, afterSetDimensions: função () {V.callback (this.options.afterSetDimensions, [esta]}), antes de os limites de dados : function () {V.callback (this.options.beforeDataLimits,[Este])} Determinar os limites de dados: V.noop, após os limites de dados: (função) {V.callback (this.options.afterDataLimits, [Esta])}, antes da compilação carrapatos: function () {V.callback (this.options.beforeBuildTicks, [this])}, buildTicks: V.noop, afterBuildTicks: function (t) {var e = this; retorno sobre (t) && t.length? V.callback (e.options.afterBuildTicks, [e, t]): (e.ticks = V.callback (e.options.afterBuildTicks, [e, e.ticks]) || e.ticks, t)}, beforeTickToLabelConversion: função () {V.callback (this.options.beforeTickToLabelConversion, [ this])}, convertTicksToLabels: function () {var t = this.options.ticks; this.ticks = this.ticks.map (t.userCallback || t.callback, this)}, afterTickToLabelConversion: function () {V .callback (this.options.afterTickToLabelConversion, [this])}, antes de CalculateTickRotation: function () {V.callback (this.options.beforeCalculateTickRotation, [this])}, calculeTickRotation: function () {var t, e, n, i, a, r, o,. S = isso, l = s.options, u = l.ticks, d = s.getTicks () de comprimento, h = u.minRotation || 0, c = u.maxRotation, f = h ;! S._isVisible ( !) || || u.display h> = c || d <= 1 || s.isHorizontal () s.labelRotation = h? (e = (t = s._getLabelSizes ()) widest.width. , n = t.highest.height-t.highest.offset, i = Math.min (s.maxWidth, s.chart.width-e), e + 6> (a = l.offset? s.maxWidth / d : i / (d-1)) && (a = i / (d- (l.offset 0,5: 1)), R = s.maxHeight-CN (l.gridLines) -u.padding-fn (l .scaleLabel), o = Math.sqrt (e * e * n + n), f = V.toDegrees (Math.min (math.asin (Math.min ((t.highest.height + 6) /, um 1 )), math.asin (Math.min (R / O, 1)) - math.asin (n / O))), F = Math.max (h, Math.min (C, F))), s .labelRotation = f)}, afterCalculateTickRotation: função () {V.callback (this.options.afterCalculateTickRotation, [este])}, beforeFit: função () {V.callback (this.options.beforeFit, [este])} , fit: function () {var t = isso, e = t.minSize = {largura: 0, altura: 0}, n = gráfico de t, i = opções de t, a = i.ticks, r = i.etiqueta escala, o = i.gridLines, s = t._isVisible (), l = "bottom" === i.position, u = t.isHorizontal (); if (u = e.width t.maxWidth: s && (? e.width = cn (o) + fn (r)), u? s && (e.height = cn (o) + fn (r)): e.height = t.maxHeight, a.display && s) {var d = pn (um), h = t._getLabelSizes (), c = h.first, f = h.last, g = h.widest, p = h.highest, m = 0,4 * d.minor.lineHeight, v = a.padding; if (u) {var b = 0! == t.labelRotation, x = V.toRadians (t.labelRotation), y = Math.cos (x), _ = Math.sin (x), k = _ * g.width + y *: + (b 0 ?: m) (? p.height- (b P.OFFSET 0)); e.height = Math.min (tcom (), i = {maxTicks: n = Math.max (2, n), min: e.min, máx: e.max, precisão: e.precision, tamanho do passo: V.valueOrDefault (e.fixedStepSize, e. stepSize)}, a = t.ticks = function (t, e) {var n, i, a, r, o = [], s = t.stepSize, l = s || 1, u = t.maxTicks- 1, d = t.Min, h = t.MAX, c = t.precision, f = e.min, g = e.max, p = V.niceNum ((gf) / U / L) * L; se (p <1e-14 && Mn (d) && Mn (h)) de retorno [f, g] (r = Math.ceil (g / p) -Math.floor (f / p))> u && (p = V.niceNum (r * p / u / l) * l), s || Mn (c)? N = Math.pow (10, V._decimalPlaces (p)) :( n = Math.pow (10, c), p Math.ceil = (p * n) / n), I = Math.floor (f / p) * p, a = Math.ceil (g / p) * P, s && (! Mn (d) && V.almostWhole ( d / p, p / 1e3) && (i = d),! Mn (h) && V.almostWhole (h / p, p / 1e3) && (a = H)), R = (ai) / p, r = V.almostEquals (r, Math.round (r) p / 1e3) Math.round (r) :? Math.ceil (R), i = Math.round (i * n) /n,a=Math.round (a * n) /n,o.push (Mn (d)? i: d); para (var m = 1; m <r; ++ m) o.push (Math.round ((i + m * p) * n) / n); return o.empurrão (Mn (h) um:? h), o} (i, t); t.handleDirectionalChanges () t.MAX = V.max (a), t.Min = V.min (a), e. ? (a.reverse () = t.start t.MAX, t.End = t.Min) :( t.start = t.Min, t.End = t.MAX)} convertTicksToLabels reversa: () função {var t = this; t.ticksAsNumbers = t.ticks.slice (), t.zeroLineIndex = t.ticks.indexOf (0), xn.prototype.convertTicksToLabels.call (t)}, _ configure: function () {var T, e = isto, n = e.getTicks (), i = e.min, a = e.max; xn.prototype._configure.call (e), e.options.offset && && n.length (i = t = (ai) /Math.max (n.length-1,1) / 2, a + = t), i = e._startValue, e._endValue = a, = e._valueRange ai}}), Cn = {posição: "left", ticks: {callback: rn.formatters.linear}}; função Pn (t, e, n, i) {var a, r, o = t.options, s = function (t, e, n) {var i = [n.type, void 0 === e && void 0 === n.stack? n.index: "", n.stack] .join ("."); retornar void 0 === t [ i] && (t [i] = {pos [], neg: []}), t [i]} (e, o.stacked, n), l = s.pos, u = s.neg, d = i.length; para (a = 0, um <d; ++ um) r = t._parseValue (i [a]), isNaN (r.min) || isNaN ( r.max) || n.data [a] .hidden || (l [a] = l [a] || 0, u [a] = u [a] || 0, o.relativePoints? l [a ] = 100: r.min <0 || r.max <0? U [a] + = r.min: l [a] + = r.max)} função An (t, e, n) {var i , a, r = n.length; para (i = 0; i <r; i ++) a = t._parseValue (n [i]), isNaN (a.min) || isNaN (a.max) | | e.data [i] .hidden || (t.min = Math.min (t.min, a.min), t.max = Math.max (t.max, a.max))} var Dn = Sn.extend ({determineDataLimits: function () {var t, e, n, i, a = this, r = a.options, o = a.chart.data.datasets, s = a._getMatchingVisibleMetas (), l = r.stacked, u = {}, d = s.length; if (a.min = Number.POSITIVE_INFINITY, a.max = Number.NEGATIVE_INFINITY, void 0 === l) para (t = 0 ;! l && t <d ; ++ t) l = nulo 0! == (e = s [t]). pilha; para (t = 0; t <d; ++ t) n = o [(e = s [t]). ? índice] .data, Pn l (a, u, e, n): um (a, e, n); V.each (u, (função (t) {i = t.pos.concat (t.neg ) a.min = Math.min (a.min, V.min (i)), a.max = Math.max (a.max, V.? Max (i))})) = a.min V.isFinite (a.min) && isNaN (a.min) a.min: 0, a.max = V.isFinite (a.max) &&! isNaN (a.max)? a.max: 1, a.handleTickRangeOptions ()}, _ computeTickLimit: function () {var t; retorna this.isHorizontal ()? Math.ceil (this.width / 40) :( t = V.options._parseFont (this.options.ticks) Math.ceil (This.Height / t.lineHeight))} handleDirectionalChanges: função () {this.isHorizontal () || this.ticks.reverse ()}, getLabelForIndex: function (t, e) {retorna this._getScaleLabel (this.chart.data.datasets [e] .data [t])}, getPixelForValue: function (t) {retorna this.getPixelForDecimal ((+ this.getRightValue ( t) - this._startValue) / this._valueRange)}, getValueForPixel: function (t) {retorna this._startValue + this.getDecimalForPixel (t) * this._valueRange}, getPixelForTick: function (t) {var e = this. ticksAsNumbers; return t <0 || t> e.length-1? null: this.getPixelForValue (e [t])}}), Tn = Cn; Dn._defaults = Tn;var In = V.valueOrDefault, Fn = V.math.log10; var Ln = {position: "left", assinala: {callback: rn.formatters.logarithmic}}; function On (t, e) {return V.isFinite (t) && t> = 0? t: e} var Rn = xn.extend ({determineDataLimits: function () {var t, e, n, i, a, r, o = this, s = o.options, l = o.chart, u = l.data.datasets, d = o.isHorizontal (); function h (t) {return d? t.xAxisID === o.id:t.yAxisID===o.id} o.min = Number.POSITIVE_INFINITY, o.max = Number.NEGATIVE_INFINITY, o.minNotZero = Number.POSITIVE_INFINITY; var c = s.stacked; if (void 0 === c) for (t = 0; t <u. comprimento; t ++) if (e = l.getDatasetMeta (t), l.isDatasetVisible (t) && h (e) && void 0! == e.stack) {c =! 0; break} if (s.stacked || c ) {var f = {}; para (t = 0; t <u.length; t ++) {var g = [(e = l.getDatasetMeta (t)). type, void 0 === s.stacked && void 0 = == e.stack? t: "", e.stack] .join ("."); if (l.isDatasetVisible (t) && h (e)) para (void 0 === f [g] && (f [g] = []), a = 0, r = (i = u [t] .data) .length; a <r; a ++) {var p = f [g]; n = o._parseValue (i [a]), isNaN (n.min) || isNaN (n.max) || e.data [a] .hidden n.min || <|| 0 n.max <0 || (p [ a] = p [a] || 0, p [a] + = n.max)}} V.each (f, (função (t) {if (comprimento de t> 0) {var e = V.min (t), n = V.max (t); o.min = Math.min (o.min, e), o.max = Math.max (o.max, n)}}))} mais para ( t = 0; t <u.length; T ++) se (e = l.getDatasetMeta (t), l.isDatasetVisible (t) && h (e)) para (a = 0, R = (i = U [t]. dados) .length; um <r; a ++) n = o._parseValue (i [a]), isNaN (n.min) || isNaN (n.max) || e.data [a] .hidden n || .min <0 || n.max <0 || (o.min = Math.min (n.min, o.min) o.max = Math.max (n.max, o.max), 0! == n.min && (o.minNotZero = Math.min (n.min, o.minNotZero))); o.min = V.isFinite (o.min) o.min: nulo, o.max = V. isFinite (o.max)? o.max: null, o.minNotZero = V.isFinite (o.minNotZero)? o.minNotZero: null, this.handleTickRangeOptions ()}, handleTickRangeOptions: function () {var t = this, e = t.options.ticks ;! t.Min = ON (e.min, t.Min) t.MAX = ON (e.max, t.MAX) t.Min === t.MAX && (0 == t. ! == min t.Min && zero (= t.Min Math.pow (10, Math.floor (Fn (t.Min)) - 1) = t.MAX Math.pow (10, Math.floor (Fn ( t.MAX)) + 1)) :( t.Min = 1, t.MAX = 10)), null === && t.Min (t.Min = Math.pow (10, Math.floor (Fn (t ! .max)) - 1)), null === t.MAX && (t.MAX = 0 == t.Min Math.pow (10, Math.floor (Fn (t.Min)) + 1) :? 10), nulo === t.minNotZero && (t.Min> 0 = t.minNotZero t.Min: t.MAX <1 t.minNotZero = Math.pow (10, Math.floor (Fn (t.MAX? ))): t.minNotZero = 1)}, buildTicks: function () {var t = isso, e = t.options.ticks, n =! t.isHorizontal (), i = {min: Ligado (e.min ), max: Ativado (e.max)}, a = t.ticks = function (t, e) {var n, i, a = [], r = In (t.min, Math.pow (10, Math .floor (Fn (e.min)))), o = Math.floor (Fn (e.max)), s = Math.ceil (e.max / Math.pow (10, O)); == 0 = r? (n = Math.floor (Fn (e.minNotZero)), i = Math.floor (e.minNotZero / Math.pow (10, n)), a.push (R), r = i * Math .pow (10, n)):(n = Math.floor (Fn (r)), i = Math.floor (r / Math.pow (10, n))); var l = n <0? Math.pow (10, Math.abs (n )):? 1; fazer {a.push (R), 10 === && ++ i (i = 1, l = ++ n> = 0 1 l), r = Math.round (i * Math. pow (10, n) * l) / l} while (n <o || n === o && i <s); var u = In (t.max, r); retorna a.push (u), a} (i, t); t.MAX = V.max (a), t.Min = V.min (a), e.reverse (n = n = t.start t.MAX, t.End =? t.Min) :( t.start = t.Min, t.End = t.MAX), n && a.reverse ()}, convertTicksToLabels: função () {this.tickValues ​​= this.ticks.slice () xn. prototype.convertTicksToLabels.call (this)}, getLabelForIndex: function (t, e) {retorna this._getScaleLabel (this.chart.data.datasets [e] .data [t])}, getPixelForTick: function (t) {var e = this.tickValues; return t <0 || t> e.length-1? null: this.getPixelForValue (e [t])}, _ getFirstTickValue: function (t) {var e = Math.floor (Fn (t )); return Math.floor (t / Math.pow (10, e)) * Math.pow (10, e)}, _ configure: function () {var t = this, e = t.min,n = 0; xn.prototype._configure.call (t), 0 && === E (E = t._getFirstTickValue (t.minNotZero), n = Em (t.options.ticks.fontSize, z.global.defaultFontSize) /t._length),t._startValue=Fn(e),t._valueOffset=n,t._valueRange=(Fn(t.max)-Fn(e)) / (1-n)}, getPixelForValue: função ( t) {var e = this, n = 0; return (t = + e.getRightValue (t))> e.min && t> 0 && (n = (Fn (t) -e._startValue) /e._valueRange+e. _valueOffset), e.getPixelForDecimal (n)}, getValueForPixel: function (t) {var e = this, n = e.getDecimalForPixel (t); return 0 === n && 0 === e.min? 0: Math.pow (10, e._startValue + (ne._valueOffset) * e._valueRange)}}), zn = Ln; Rn._defaults = zn; var Nn = V.valueOrDefault, Bn = V.valueAtIndexOrDefault, En = V.options.resolve , Wn = {display: 0, animado :! 0, posição: "área do gráfico", linhas angulares: {display: 0, cor: "rgba (0,0,0,0.1)", da largura de linha: 1, borderDash: [ ] borderDashOffset: 0}, linhas de grade: {circular:1}, carrapatos {showLabel contexto: 0, cor de fundo: "rgba (255,255,255,0.75)" backdropPaddingY: 2, backdropPaddingX: 2, de retorno de chamada: rn.formatters.linear}, etiquetas de pontos: {display: 0, o tamanho da fonte: 10 , callback: function (t) {return t}}}; function Vn (t) {var e = t.ticks; return e.display && t.display? Nn (e.fontSize, z.global.defaultFontSize) + 2 * e .backdropPaddingY: 0} função Hn (t, e, n, i, a) {return t === i || t === a? {start: pt / 2, end: e + n / 2}: t <i || t> a? {start: pt, end: e}: {start: e, end: e + n}} função jn (t) {return 0 === t || 180 === t? "center": t <180? "left": "right"} função qn (t, e, n, i) {var a, r, o = n.y + i / 2; if (V.isArray (e )) para (a = 0, r = e.length; a <r; ++ a) t.fillText (e [a], nx, o), o + = i; caso contrário, t.fillText (e, nx, o )} função Un (t, e, n) {90 === t || 270 === t? ny- = eh / 2: (t> 270 || t <90) && (ny- = eh)} função Yn (t) {retornar V.isNumber (t)? t: 0} var Gn = Sn.extend ({setDimensions:function () {var t = this; t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = Vn (t.options) /2,t.xCenter=Math.floor (t.width / 2) t.yCenter Math.floor = ((t.height-t.paddingTop) / 2) = t.drawingArea Math.min (t.height-t.paddingTop, t.width) / 2}, os dados Determinar limites: function () {var t = this, e = t.chart, n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY; V.each (e.data.datasets, (function (a, r) ​​{if (e.isDatasetVisible (r)) {var o = e.getDatasetMeta (r); V.each (a.data, (função (e, a) {var r = + t.getRightValue (e); isNaN (r) || o. dados [a] || .hidden (n = Math.min (r, N), i = Math.max (r, i))}))}})) = n t.Min === Number.POSITIVE_INFINITY ? 0: n, t.max = i === Number.NEGATIVE_INFINITY? 0: i, t.handleTickRangeOptions ()}, _ computeTickLimit: function () {retorna Math.ceil (this.drawingArea / Vn (this.options)) } convertTicksToLabels: function () {var t = this; Sn.prototype.convertTicksToLabels.call (t), t.pointLabels = t.chart.data.labels.map ((function () {var e = V. callback (t.options.pointLabels.callback, argumentos, t); return e || 0 === e? e: ""}))}, getLabelForIndex: function ( t, e) {return + this.getRightValue (this.chart.data.datasets [e] .data [t])}, fit: function () {var t = this.options; t.display && t.pointLabels.display? função (t) {var e, n, i, a = V.options._parseFont (t.options.pointLabels), r = {l: 0, r: t.width, t: 0, b: t.height- t.paddingTop}, o = {}; t.ctx.font = a.string, t._pointLabelSizes = []; var s, l, u, d = t.chart.data.labels.length; for (e = 0; e <d; e ++) {i = t.getPointPosition (s, t.drawingArea + 5), s = t.ctx, l = a.lineHeight, u = t.pointLabels [e], n = V.isArray ? (u) {w: V.longestText (s, s.font, u), h: u.length * l} {w: s.measureText (u) .width, h: l}, t._pointLabelSizes [ e] = n; var h = t.getIndexAngle (e), c = V. para Graus (h)% 360, f = Hn (c, ix, nw, 0,180), g = Hn (c, iy, nh, 90.270 ); f.start <rl && (rl = f.start, ol = H), f.end> rr && (r.r = f.end, ou = h), g.start <&& rt (ta = g.start, ot = H), g.end> rb && (RB = g.end se = H)} t.setReductions (t .drawingArea, r, o)} (this): this.setCenterPoint (0,0,0,0)}, setReductions: function (t, e, n) {var i = this, a = el / Math.sin ( nl), r = Math.max (er-i.width, 0) /Math.sin (nr), o = -et / Math.cos (nt) s = -Math.max (EB (i.height -i.paddingTop), 0) /Math.cos (NB); a = Yn (a), r = Yn (r), o = (s Yn (o) s Y = N), i.drawingArea = Math. min (Math.floor (t (a + R) / 2), Math.floor (t- (O + s) / 2)), i.setCenterPoint (a, r, O, s)}, setCenterPoint: função (t, e, n, i) {var a = this, r = a.width-ea.drawingArea, o = t + a.drawingArea, s = n + a.drawingArea, l = a.height-a.paddingTop -ia.drawingArea; a.xCenter Math.floor = ((o + r) /2+a.left) a.yCenter Math.floor = ((s + l) /2+a.top+a.paddingTop) }, getIndexAngle: function (t) {var e = this.chart, n = (t * (360 / e.data.labels.length) + ((e.options || {}). startAngle || 0)) % 360; retorno (n <0 n + 360:? n) * Math.PI * 2/360}getDistanceFromCenterForValue: function (t) {var e = this; if (V.isNullOrUndef (t)) retorna NaN; var n = e.drawingArea / (e.max-e.min); return e.options.ticks.reverse? (e.max-t) * n: (te.min) * n}, getPointPosition: função (t, e) {var n = this.getIndexAngle (t) -Math.PI / 2; return {x: Math. cos (n) * e + this.xCenter, y: Math.sin (n) * e + this.yCenter}}, getPointPositionForValue: function (t, e) {retorna this.getPointPosition (t, this.getDistanceFromCenterForValue (e) )}, getBasePosition: function (t) {var e = this.min, n = this.max; retorna this.getPointPositionForValue (t || 0, this.beginAtZero? 0: e <0 && n <0? n: e> 0 && n > 0? E: 0)}, _ drawGrid: function () {var t, e, n, i = this, a = i.ctx, r = i.options, o = r.gridLines, s = r.angleLines, l = Nn (s.lineWidth, o.lineWidth), u = Nn (s.color, o.color); if (r.pointLabels.display && function (t) {var e = t.ctx, n = t.options, I = n.pointLabels, um Vn = (n), r = t.getDistanceFromCenterForValue (n.ticks.reverse? t.min: t.max), o = V.options._parseFont (i); e.save (), e.font = o.string, e.textBaseline = "middle"; for (var s = t.chart.data.labels.length-1; s> = 0; s -) {var l = 0 === s? a / 2: 0, u = t.getPointPosition (s, r + l + 5), d = Bn (i.fontColor, s, z.global.defaultFontColor); e.fillStyle = d; var h = t.getIndexAngle (s), c = V.toDegrees (h); e.textAlign = jn (c), A (c, t._pointLabelSizes [s], u), qn (s, t.pointLabels [s], u, o.lineHeight)} e.restore ()} (i), o.display && V. cada (i.ticks, (função (t, n) {0! == n && (e = i.getDistanceFromCenterForValue (i.ticksAsNumbers [n])), função (t, e, n, i) {var a, r = t.ctx, o = e.circular, s = t.chart.data.labels.length, l = Bn (e.color, i-1), u = Bn (e.lineWidth, i-1); if ( (O || s) && && G U) {if (r.save () r.strokeStyle = l, u = r.lineWidth, r.setLineDash && (r.setLineDash (e.borderDash || []), r.lineDashOffset = e.borderDashOffset || 0), r.beginPath () o) r.arc (t.xCenter, t.yCenter, n, 0.2 * Math.PI); else {a = t.getPointPosition (0, n), r.moveTo (ax, ay); for (var d = 1; d <s; d ++) a = t.getPointPosition (d, n), r.lineTo (ax, ay)} r.closePath () r.stroke () r.restore ()}} (I, O, S, N))})) , s.display l && && u) {para (a.save () a.lineWidth = l, u = a.strokeStyle, a.setLineDash && (a.setLineDash (En ([s.borderDash, o.borderDash, []])) , a.lineDashOffset = En ([s.borderDashOffset, o.borderDashOffset, 0])), t = i.chart.data.labels.length-1; t> = 0; t -) e = i.getDistanceFromCenterForValue ( ? r.ticks.reverse i.min: i.max), n = i.getPointPosition (t, e), a.beginPath () a.moveTo (i.xCenter, i.yCenter) a.lineTo (nx , ny), a.stroke (); a.restore ()}}, _ drawLabels: function () {var t = isso, e = t.ctx, n = t.options.ticks; if (n.display) { var i, a, r = t.getIndexAngle (0), o = V.options._parseFont (n), s = Nn (n.fontColor, z.global.defaultFontColor); e.save (), e.font = o.string, e.translate (t.xCenter, t.yCenter), e.de rotação (R), e.textAlign = "centro", e.textBaseline = "middle" V.each (t.ticks, (função de (R, L,) {(0 == l || n.reverse) && (i = t.getDistanceFromCenterForValue (t.ticksAsNumbers [l]) && n.showLabelBackdrop (a = e.measureText (r) .width, e.fillStyle = n.backdropColor, e.fillRect (-a / 2 n.backdropPaddingX , -io.size / 2 n.backdropPaddingY, a + 2 * n.backdropPaddingX, o.size + 2 * n.backdropPaddingY)) = s e.fillStyle, e.fillText (r, 0, -i)) })), e.restore ()}}, _ drawTitle: V.noop}), Xn = Wn; Gn._defaults = Xn; var Kn = V._ reprovado, Zn = V.options.resolve, $ n = V. valueOrDefault, Jo = Number.MIN_SAFE_INTEGER || -9.007.199.254.740.991, Qn = Number.MAX_SAFE_INTEGER || 9007199254740991, ti = {milissegundo: {comum: 0, tamanho: 1, passos: 1E3}, segundo: {comuns: 0, tamanho : 1E3, passos: 60}, {min comum: 0, tamanho: 6e4, etapas: 60} horas {comuns: 0, tamanho: 36e5, etapas: 24}, dia: {comum: 0, size: 864e5, passos: 30}, semana {comum: 1, tamanho: 6048e5,etapas: 4}, mês: {comum: 0, tamanho: 2628e6, passos: 12}, bairro: {comum: 1, tamanho: 7884e6, os passos 4}, ano: {comum: 0, tamanho: 3154e7 }}, ei = Object.keys (ti); função ni (t, e) {retorno te} função ii (t) {retorno V.valueOrDefault (t.time.min, t.ticks.min)} função ai ( t) {return V.valueOrDefault (t.time.max, t.ticks.max)} função ri (t, e, n, i) {var a = função (t, e, n) {for (var i, a, R, o = 0, s = T.Length-1; o> = 0 && s <= s;) {if (a t = [(i = O + s >> 1) -1] || zero, r ! = t [i], a) {return lo: zero, oi: r}; if (r [e] <n) o = i + 1, se (a [e] else {(> n)) return {eis: a, oi: r} s = i-1}} retorno {eis: r, oi: null}} (t, s, N), r = a.lo a.hi a.lo :? t [T.Length-2]: T [0], o = a.lo a.hi a.hi :? t [T.Length-1]: t [1], S = O [e] -r [e], l = s? (nr [e]) / s: 0, u = (o [i] -r [i]) * l; retorna r [i] + u} função oi (t, e) {var n = adaptador t.i, t = opções.time, a = analisador i, r = a || formato i, o = e; return "function" == typeof a && (o = a (o) ) V.isFinite (o) || (o = "string"== tipo de r? n.parse (o, r): n.parse (o)), nulo! == o? + o: (a || "função"! = tipo de r || (o = r (e ), V.isFinite (o) || (o = n.parse (o))), o)} função si (t, e) {if (V.isNullOrUndef (e)) retorna nulo; var n = t. Opções.time, i = oi (t, t.getRightValue (e)); return null === i? i: (n.round && (i = + t._adapter.startOf (i, n.round)), i )} função li (t, e, n, i) {var a, r, o, s = ei.length; for (a = ei.indexOf (t); a <s-1; ++ a) if ( o = (r = ti [ei [a]]). passos? r.steps: Qn, r.common && Math.ceil ((ne) / (o * r.size)) <= i) return ei [a]; return ei [s-1]} função ui (t, e, n) {var i, a, r = [], o = {}, s = comprimento e.; for (i = 0; i <s; + + i) o [a = e [i]] = i, r.push ({valor: a, major :! 1}); retorne 0! == s && n? função (t, e, n, i) {var a, R, o = t._adapter, s = + o.startOf (e [0] .value, i) .value = e L [e.length-1]; para (a = s; a <= G ; a = + o.adicionar (a, 1, i)) (r = n [a])> = 0 && (e [r] .maior =! 0); retornar e} (t, r, o, n) : r} var di = xn.extend ({initialize: function () {this.mergeTicksOptions (), xn.prototype.initialize.call (this)}, update: function () {var t = this, e = t.options, n = e.time || (e.time = {}), i = t._adapter = new an._date (e.adapters.date); retorna Kn ("escala de tempo", n.format, "time.format", "time.parser"), Kn ("escala de tempo", n .min, "time.min", "ticks.min"), Kn ("escala de tempo", n.max, "time.max", "ticks.max"), V.mergeIf (n.displayFormats, i. Formatos ()), xn.prototype.update.apply (t, argumentos)}, getRightValue: function (t) {return t && void 0! == tt && (t = tt), xn.prototype.getRightValue.call (this, t )}, determineDataLimits: function () {var t, e, n, i, a, r, o, s = isto, l = s.chart, u = s._adapter, d = s.options, h = d. time.unit || "dias", c = Qn, Jo = f, g = [], p = [], m = [], v = s._getLabels (); para (t = 0, n = v. comprimento; para (t = 0, n = (|| l.data.datasets []) comprimento ;; t <n t <n;. t) m.push (Si (s, v [t])) ++ ;++ t) se (l.isDatasetVisible (t)) if (a = l.data.datasets [t] .data, V.isObject (a [0])) para (p [t] = [] = E 0, i = a.length; e <i; ++ e) r = si (s, a [e]), g.push (r), p [t] [e] = r; senão p [t] = m.slice (0), o || (g = g.concat (m), o =! 0); senão p [t] = []; m.length && (c = Math.min (c, m [ 0]), f = Math.max (f, m [m.length-1])), g.length && (g = n> 1? Função (t) {var e, n, i, a = {}, r = []; para (e = 0, n = T.Length; e <n; ++ e) a [i = t [e]] || (a [i] = 0, r.push (i! )); return r} (g) .sort (ni): g.sort (ni), c = Math.min (c, g [0]), f = Math.max (f, g [g.length- 1])), c = SI (s, ii (d)) || c, f = s (s, I (d)) || f, c = c === Qn? + u.startOf (Data. agora (), h): c, f = f === Jo + u.endOf (Date.now () h,) 1 = :? f s.min Math.min (c, f), s. max = Math.max (c + 1, f), s.table = [], s._timestamps = {dados: g, conjuntos de dados: p, rótulos: m}}, buildTicks: function () {var t, e, n, i = isso, um i.min =, r = i.max, o = i.options, s = o.ticks, l = o.time, u = i._timestamps, d = [], h = i .getLabelCapacity (a), c = s.source, f = o.distribution; para (U = "dados"=== c || "auto" === c && "series" === para dados: "labels" === c? u.labels: function (t, e, n, i) {var a , r = t._adapter, o = t.options, s = o.time, l = s.unit || li (s.minUnit, e, n, i), u = Zn ([s.stepSize, s. o tamanho da unidade passo, 1]), d = "semana" l === && s.isoWeekday, H = e, C = []; if (d && (h = + r.startOf (h, "isoWeek", d)), h = + r.startOf (h, d? "dia": l), r.diff (n, e, l)> 1e5 * u) lance e + "e" + n + "estão muito distantes com stepSize de" + u + " "+ l; para (a = h; a <n; a = + r.adicionar (a, u, l)) c.push (a); retorne a! == n &&" ticks "! == o.bounds || c.push (a), c} (i, a, R, h), "ticks" === o.bounds && && u.length (a = L [0], r = u [u.length-1] ), um SI = (I, II (O)) || a, r = s (i, i (o)) || r, t = 0, e = u.length; t <e; ++ t) (n = u [t])> = a && n <= r && d.push (n); return i.min = a, i.max = r, i._unit = l.unit || (s.autoSkip? li (l .minUnit, i.min, i.max, h): function (t, e, n, i, a) {var r, o; for (r = ei.length-1; r> = ei.indexOf (n); r-- ) if (o = ei [r], ti [o] .comum && t._adapter.diff (a, i, o)> = e-1) return o; return ei [n? ei.indexOf (n): 0] } (i, d.length, l.minUnit, i.min, i.max)), i._majorUnit = s.major.enabled && "year"! == i.unidad? function (t) {for (var e = ei.indexOf (t) + 1, n = ei.length; e <n; ++ e) if (ti [ei [e]]. comum) retorna ei [e]} (i._unidade): void 0 , i._table = função (T, e, n, i) {if ( "lineares" === || i T.Length) de retorno [{time: e, pos: 0}, {: n, tempo pos : 1}]; var a, r, o, s, l, u = [], d = [e]; para (a = 0, r = comprimento de t; a <r; ++ a) (s = t [a])> e && s <n && d.push (s); para (d.push (s), a = 0, r = D.Length; a) l ++ = d [a + 1]; um <r , o = d [a-1], s = d [a], vazio 0! == o && vazio 0! == l && Math.round ((l + o) / 2) === s || u.push ({ time: s, pos: a / (r-1)}); return u} (i._timestamps.data, a, r, f), i._offsets = function (t, e, n, i, a) { var r, o, s = 0, l = 0; retornar a.? Offset && e.length && (r = r (t, "tempo", e [0], "pos"), s = 1 === e.length 1-r (r (t, "tempo", e [1 ?], "pos") - R) / 2, o = ri (t, "tempo", e [e.length-1], "pos"), l = 1 === e.length o: (O ri (t, "tempo", e [e.length-2], "pos")) / 2), e {começar: s, finais: l, factor de: 1 / (s + 1 + l)}} ( i._table, d, 0,0, o), s.reverse && d.reverse (), ui (i, d, i._majorUnit)}, getLabelForIndex: função (t, e) {var n = isto, i = n ._adapter, um n.chart.data =, r = n.options.time, o = a.labels && t <a.labels.length a.labels [t]: "" s = a.datasets [e]. data [t]; return V.isObject (s) && (o = n.getRightValue (s)), r.tooltipFormat? i.format (oi (n, o), r.tooltipFormat): "string" == typeof o? o: i.format (oi (n, o), r.displayFormats.datetime)}, tickFormatFunction: function (t, e, n, i) {var a = this.adapter, r = this.options, o = r.time.displayFormats, S = O [this._unit]l = this._majorUnit, u = o [l], d = n [e], h = r.ticks, c = l && && u d && d.major, f = a.format (t, i || (c u? s) ), g = c? h.major: h.minor, p = Zn ([g.callback, g.userCallback, h.callback, h.userCallback]); return p? p (f, e, n): f } convertTicksToLabels: function (t) {var e, n, i = []; para (e = 0, n = comprimento de t; e <n; ++ e) i.push (this.tickFormatFunction (t [e ] .value, e, t)); return i}, getPixelForOffset: function (t) {var e = this._offsets, n = ri (this._table, "time", t, "pos"); retorne isso. getPixelForDecimal ((e.start + n) * e.factor)}, getPixelForValue: function (t, e, n) {var i = null; if (void 0! == e && void 0! == n && (i = this. _timestamps.datasets [n] [e]), null === i && (i = si (this, t)), null! == i) retorna this.getPixelForOffset (i)}, getPixelForTick: function (t) {var e = this.getTicks (); return t> = 0 && t <e.length? this.getPixelForOffset (e [t] .value): null}, getValueForPixel:function (t) {var e = this._offsets, n = this.getDecimalForPixel (t) /e.factor-e.end,i=ri (this._table, "pos", n, "time"); retorne isso ._adapter._create (i)}, _ getLabelSize: function (t) {var e = this.options.ticks, n = this.ctx.measureText (t) .width, i = V.toRadians (this.isHorizontal ()? e.maxRotation: e.minRotation), a = Math.cos (I), R = Math.Sin (i), o = $ n (e.fontSize, z.global.defaultFontSize); retorno {w: n * um + o * r, h: n * r + o * a}}, getLabelWidth: function (t) {retorna this._getLabelSize (t) .w}, getLabelCapacity: função (t) {var e = this, n = e .options.time, i = n.displayFormats, a = i [n.unit] || i.millisecond, r = e.tickFormatFunction (t, 0, ui (s, [t], e._majorUnit) a) , o = e._getLabelSize (r), s = Math.floor (e.isHorizontal ()? e.width / ow: e.height / oh); retorne e.options.offset && s -, s> 0? s: 1}}, oi = {posição): "inferior" distribuição "linear" limites: "dados", adaptadores: {}, tempo:{Analisador: 1, unidade: 1 rodada: 1, formato de exibição: 1, isoWeekday: 1, minUnit "milissegundos", formatos de exibição: {}}, carrapatos: {AUTOSKIP: 1, source: "auto ", major: {enabled :! 1}}}; di._defaults = oi; var ci = {categoria: _n, linear: Dn, logarítmica: Rn, radialLinear: Gn, tempo: di}, fi = {datetime:" MMM D, AAAA, h: mm: ss a ", milissegundo:" h: mm: ss.SSS a ", segundo:" h: mm: ss a ", minuto:" h: mm a ", hora:" hA ", dia:" MMM D ", semana:" ll ", mês:" MMM AAAA ", trimestre:" [Q] Q - AAAA ", ano:" AAAA "}; an._date.override (" function "= = typeof t? {_ id: "momento", formatos: function () {return fi}, análise: function (e, n) {return "string" == typeof e && "string" == typeof n? e = t ( e, n): a instância de t || (e = t (e)), e.isValid ()? e.valueOf (): null}, formato: função (e, n) {return t (e) .format (n)}, adicione:function (e, n, i) {return t (e) .add (n, i) .valueOf ()}, diff: function (e, n, i) {return t (e) .diff (t (n) , i)}, startOf: function (e, n, i) {return e = t (e), "isoWeek" === n? e.isoWeekday (i) .valueOf (): e.startOf (n). valueOf ()}, endOf: function (e, n) {return t (e) .endOf (n) .valueOf ()}, _ create: function (e) {return t (e)}}: {}), por exemplo ._set ("global", {plugins: {filler: {propagate :! 0}}}); var gi = {conjunto de dados: função (t) {var e = t.fill, n = t.chart, i = n .getDatasetMeta (e), a = i && n.isDatasetVisible (e) && i.dataset._children || [], r = a.length || 0; return r? function (t, e) {return e <r && a [e] ._view || null}: null}, limite: function (t) {var e = t.bound, n = e? ex: null, i = e? ey: null; retornar V.isArray (e)? function ( t, n) {return e [n]}: function (t) {return {x: null === n? tx: n, y: null === i? ty: i}}}}; função pi ( t, e, n) {var i, a = t._model || {}, r = a.fill; if (void 0 === r && (r = !! a.backgroundColor),!1 === === r || zero, r) de retorno 1; if (0 === r) retorno "origem"; if (i = parseFloat (r, 10), isFinite (i) && Math.floor ( i) === i) return "-"! == r [0] && "+" == r [0] || (i = e + i), (i === e || i <! 0 || i> = n) && i; switch (r) {case "bottom": return "start"; caso "top": return "final"; caso "zero": return "origem"; caso "origem": case "start": case "end": return r; default: return! 1}} função mi (t) {return (t.el._scale || {}). getPointPositionForValue? function (t) {var e, n , i,, um de R, o = t.el._scale, s = o.options, l = o.chart.data.labels.length, u = t.fill, d = []; se retorno (! l) nulo; para (e = s.ticks.reverse o.max: o.min, n = s.ticks.reverse o.min: o.max, i = o.getPointPositionForValue (0, e), a = 0? ; um <l; ++ um) r = "start" === || u "final" === u o.getPointPositionForValue (um "start" === U e :? n): O.getBasePosition (a), s.gridLines.circular && (r.cx = ix, r.cy = iy, r.angle = o.getIndexAngle (a) -Math.PI / 2), d.push (r); return d } (t): function (t) {var e, n = t.el._model || {}, i = t.el._scale || {}, a = t.fill, r = null; if (isFinite (a)) retorna null; if ("start" === a? r = void 0 === n.scaleBottom? i.bottom: n.scaleBottom: "end" === a? r = void 0 == = n.scaleTop? i.top: n.scaleTop: void 0! == n.scaleZero? r = n.scaleZero: i.getBasePixel && (r = i.getBasePixel ()), null! = r) {if (void 0! == rx && void 0! == ry) return r; if (V.isFinite (r)) return {x: (e = i.isHorizontal ())? R: null, y: e? Nulo: r}} return null} (t)} função vi (t, e, n) {var i, a = t [e] .fill, r = [e]; se (! n) retorna a; for (;! 1! = = a && - 1 === r.indexOf (a);) {if (! isFinite (a)) retorna a; if (! (i = t [a])) retorna! 1; if (i.visible) return a; r.push (a), a = i.fill} return! 1} função bi (t) {var e = t.fill, n = "conjunto de dados"; return! 1 === e? null:(isFinite (e) || (n = "limite"), gi [n] (t))} função xi (t) {return t &&! t.skip} função yi (t, e, n, i, a) {var r, o, s, l; if (i && a) {for (t.moveTo (e [0] .x, e [0] .y), r = 1; r <i; ++ r) V. canvas.lineTo (t, e [r-1], e [r]); if (void 0 === n [0] .angle) para (t.lineTo (n [a-1] .x, n [ a-1] .y), r = a-1; r> 0; - r) V.canvas.lineTo (t, n [r], n [r-1],! 0); mais para (o n = [0] .cx, s = N [0] .cy, l = Math.sqrt (Math.pow (N [0] .xo, 2) + Math.pow (N [0] .ys, 2) ), r = a-1; r> 0; - r) t.arc (o, s, l, n [r] .angle, n [r-1] .angle ,! 0)}} função _i ( t, e, n, i, a, r) ​​{var o, s, l, u, d, h, c, f, g = comprimento e, p = i.spanGaps, m = [], v = [ ], b = 0, x = 0; para (t.beginPath (), o = 0, s = g o <s; ++ O) d = N (u = e [L = O% g] ._ vista (i), h = xi (u), c = xi (d), r && void 0 === f && h && (s = g + (f = o + 1)), h && c? (b = m.push (u) , x = v.push (d)): b && x && (? p (H && m.push (u), c && v.push (d)) :( yi (t, m, v, b, x), b = x = 0 , m = [], v = [])); yi (t, m, v, b, x), t.closePath (), t.fillStyle = a, t.fill ()} var ki = {id: "filler", afterDatasetsUpdate: função (t, e) {var n, i, a, r, o = (t.data.datasets || [] ) .length, s = e.propagate, l = []; para (i = 0; i <o, i ++) r = zero (a = (n = t.getDatasetMeta (i)) do conjunto de dados) && uma. ._model && uma instância de _t.Line && (r = {visible: t.isDatasetVisible (i), fill: pi (a, i, o), chart: t, el: a}), n. $ filler = r, l.push (r); for (i = 0; i <o, i ++) (r = l [i]) && (r.fill vi = (l, i, s), r.boundary = mi (r), r.mapper = bi (r))}, beforeDatasetsDraw: function (t) {var e, n, i, a, r, o, s, l = t._getSortedVisibleDatasetMetas (), u = t.ctx; for (n l.length = 1; n> = 0, - s) (e = l [n] de enchimento $) && && e.visible (a = (i = e.el.) ._ vista, r = i._children || [] o = e.mapper, s = a.backgroundColor || z.global.defaultColor, O s && && && r.length (V.canvas.clipArea (u, t.chartArea) _ i (u, r, o, a, s , i._loop) V.canvas.unclipArea (u)))}}, wi = V.rtl.getRtlAdapter, Mi = V.noop, Si = V.valueOrDefault; function Ci (t, e) {retornar t.usePointStyle && t.boxWidth> e? e: t.boxWidth} z._set ("global", {legenda: {display :! 0, posição: "top", alinhar: "center", largura total :! 0, reverso :! 1, peso: 1e3, onClick: função (t, e) {var n = e.datasetIndex, i = this.chart, a = i.getDatasetMeta (n); a .hidden = nulo === a.hidden i.data.datasets [n] .hidden :? nula i.update ()}, onHover: nulo, OnLeave: nulo, rótulos: {bucketWidth: 40, preenchimento: 10 , generateLabels: function (t) {var e = t.data.datasets, n = t.options.legend || {}, i = n.labels && n.labels.usePointStyle; retorna t._getSortedDatasetMetas (). map ((function (n) {var a = n.controller.getStyle (i? 0: void 0); return {text: e [n.index] .label, fillStyle: a.backgroundColor, oculto :! t.isDatasetVisible (n.index ) lineCap: a.borderCapStyle, lineDash: a.borderDash, lineDashOffset: a.borderDashOffset, lineJoin: a.borderJoinStyle, largura de linha: a.borderWidth,strokeStyle: a.borderColor, pointStyle: a.pointStyle, rotação: a.rotation, datasetIndex: n.index}}), isto)}}}, legendCallback: function (t) {var e, n, i, a = document .createElement ( "ul"), r = t.data.datasets; para (a.setAttribute ( "classe", t.id + "- legenda"), e = 0, n = r.length; e <n; e ++ ) (i = a.appendChild (document.createElement ( "LI"))). appendChild (document.createElement ( "span")). style.backgroundColor = r [e] .backgroundColor, R [e] .label && i.appendChild (document.createTextNode (r [e] .label)); return a.outerHTML}}); var Pi = X.extend ({initialize: function (t) {V.extend (this, t), this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode =! 1}, beforeUpdate: Mi, atualização: function (t, e, n) {var i = this; return i.beforeUpdate (), i.maxWidth = t, i.maxHeight = e, n = i.margins, i.beforeSetDimensions () i.setDimensions () i.afterSetDimensions (), i.antes de etiquetas build (), i.buildLabels () i.afterBuildLabels () i.beforeFit () i.fit () i.afterFit () i.afterUpdate ()} i.minSize, após a atualização: Mi, beforeSetDimensions : Mi, setDimensions: function () {var t = this; t.isHorizontal ()? (T.width = t.maxWidth, t.left = 0, t.right = t.width) :( t.height = t .maxHeight, t.top = 0, = t.bottom t.height) t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {largura: 0 , height: 0}}, afterSetDimensions: Mi, beforeBuildLabels: Mi, buildLabels: function () {var t = isso, e = t.options.labels || {}, n = V.callback (e.generateLabels, [t .chart], t) || []; e.filter && (n = n.filter ((function (n) {return e.filter (n, t.chart.data)}))), t.options.reverse && n .reverse (), t.legendItems = n}, afterBuildLabels: Mi, beforeFit: Mi, ajuste: function () {var t = this, e = t.options, n = e.labels, i = e.display, a = t.ctx, r = V.options._parseFont (n), o = r.size, s = t.legendHitBoxes = [], l = t.minSize, u = t.isHorizontal (); if (u (l.width = t.maxWidth, l.height = i 10: 0) :( l.width I = 10: 0, l.height = t.maxHeight ???), i) {if (a.font = r.string, u) {var d = t.lineWidths = [0], h = 0; a.textAlign = "left", a.textBaseline = "middle", V.each (t .legendItems, (function (t, e) {var i = Ci (n, o) + o / 2 + a.measureText (t.text) .width; (0 === e || d [d.length- 1] + i + 2 * n.padding> l.width) && (H + = o + n.padding, d [d.length- (e> 0 0: 1)] = 0), S [e] = {esquerda: 0, superior: 0, largura: i, altura: o}, d [comprimento d-1] + = i + n.preenchimento})), altura l + = h} mais {var c = n. preenchimento, f = t.columnWidths = [], g = t.columnHeights = [], p = n.padding, m = 0, v = 0; V.each (t.legendItems, (função (T, e) { var i = Ci (n, o) + o / 2 + a.measureText (t.text) .width; e> 0 && v + o + 2 * c> l.height && (p + = m + n.padding, f.push (m), g.push (v), m = 0, v = 0), m = Math.max (m, i), v = + o + s c [e] = {à esquerda, 0, topo: 0 , largura: i, altura: o}})), p = m +, f.push (m), g.push (v), l.width + = p} = t.width l.width, t.height = l ,height} else t.width = l.width = t.height = l.height = 0}, afterFit: qua, isHorizontal: function () {return "top" === this.options.position || "bottom" = == this.options.position}, draw: function () {var t = this, e = t.options, n = e.labels, i = z.global, a = i.defaultColor, r = i.elements. linha, o = t.height, s = t.columnHeights, l = t.width, u = t.lineWidths; if (e.display) {var d, h = wi (e.rtl, t.left, t. minSize.width), c = t.ctx, f = Si (n.fontColor, i.defaultFontColor), g = V.options._parseFont (n), p = g.size; c.textAlign = h.textAlign ( " esquerda "), c.textBaseline =" meio ", c.lineWidth = 0,5, c.strokeStyle = f, c.fillStyle = f, c.font = g.string; var m = Ci (n, p), v = t.legendHitBoxes, b = function (t, i) {switch (e.align) {case "start": retorna n.padding; case "end": return ti; padrão: return (t-i + n.padding ) / 2}}, x = t.isHorizontal (); d = x {x: t.left + b (l, L [0]), y: n.padding t.top +, linha: 0}: {x: t.left + n.padding, y: t.top + b (o, s [0]), linha: 0}, V.rtl.overrideTextDirection (t.ctx, e.textDirection); var y = p + n.padding; V.each (t.legendItems, ( função (e, i) {var f = c.measureText (e.text) .width, g = m + p / 2 + f, _ = dx, k = dy; h.setWidth (t.minSize.width), x? i> 0 && _ + g + n.padding> t.left + t.minSize.width && (k = d.y + = y, d.line ++ _ = dx = t.left + b (l, u [d. A linha])): i> 0 && k + y> t.top + t.minSize.height && (_ = _ = dx + t.columnWidths [d.line] + n.padding, d.line ++, k = dy = t. top + b (o, s [linha.de])); var w = hx (_);! function (t, e, i) {if (! (isNaN (m) || m <= 0)) { Você pode usar o seguinte código: c.save (); var o = Si (i.lineWidth, r.borderWidth); if (c.fillStyle = Si (i.fillStyle, a), c.lineCap = Si (i.lineCap, r.borderCapStyle), c.lineDashOffset = Si (i.lineDashOffset, r.borderDashOffset) c.lineJoin = Si (i.lineJoin, r.borderJoinStyle) c.lineWidth = O, c.strokeStyle = Si (i.strokeStyle, a), c .setLineDash && c.setLineDash (Si (i.lineDash, r.borderDash)), n &&n.usePointStyle) {var s = m * Math.SQRT2 / 2, l = h.xPlus (t, m / 2), u = e + p / 2; V.canvas.drawPoint (c, i.pointStyle, s , l, u, i.rotation)} else c.fillRect (h.leftForLtr (t, m), e, m, p), 0! == o && c.strokeRect (h.leftForLtr (t, m), e, m, p); c.restore ()}} (w, k, e), v [i] = .left h.leftForLtr (w, v [i] .width), v [i] = k .TOP, A função (t, e, n, i) {var a = p / 2, r = h.xPlus (t, m + a), o = e + a; c.fillText (n.text, r, o), n.hidden && (c.beginPath () c.lineWidth = 2, c.moveTo (R, O), c.lineTo (h.xPlus (r, i), o), c.stroke ())} (w , K, e, F), x = g + + d.x n.padding: d.y + = y})), V.rtl.restoreTextDirection (t.ctx, e.textDirection)}} _ getLegendItemAt: função ( t, e) {var n, i, a, r = this; if (t> = r.left && t <= r.right && e> = r.top && e <= r.bottom) para (a = r.legendHitBoxes, n = 0; n <a.length; n ++) se (t>. = (i = a [n]) && t esquerda <= i.left + i.width && e> = i.top && e <= i.top + i.height ) return r.legendItems [n]; return null},handleEvent: function (t) {var e, n = isto, i = n.opções, a = "mouseup" === t.type? "clique": t.type; if ("mousemove" === a) {if (! i.onHover && i.onLeave) return} else {if ( "clique" == a) retorno; se o retorno (i.onClick!)} e = n._getLegendItemAt (tx, ty) ", clique em "=== ae && && i.onClick i.onClick.call (n, t.native, e)? :( i.onLeave && e! == n._hoveredItem && (&& n._hoveredItem i.onLeave.call (n, t.native, n. _hoveredItem), n._hoveredItem = e), i.onHover && e && i.onHover.call (n, t.native, e))}}); function Ai (t, e) {var n = new Pi ({ctx: t. ctx, opções: e, chart: t}); ge.configure (t, n, e), ge.addBox (t, n), t.legend = n} var Di = {id: "legend", _ elemento: Pi, beforeInit: função (t) {var e = t.options.legend; e && Ai (t, e)}, beforeUpdate: função (t) {var e = t.options.legend, n = t.legend; e? (V.mergeIf (e, z.global.legend) n? (ge.configure (t, n, e), n.options = e): Ai (t, e)): n && (ge.removeBox (t, n), exclua t.legend)}, afterEvent: function (t, e) {var n = t.legend; n && n.handleEvent (e)}}, Ti = V.noop; z._set ("global", {title: {display :! 1, fontStyle: "bold", fullWidth :! 0 , padding: 10, position: "top", texto: "", weight: 2e3}}); var Ii = X.extend ({initialize: function (t) {V.extend (this, t), this.legendHitBoxes = []}, antes de Atualizar: Ti, atualizar: função (t, e, n) {var i = this; retornar i.beforeUpdate (), i.maxWidth = t, i.maxHeight = e, i.margins = n, i.beforeSetDimensions () i.setDimensions () i.afterSetDimensions () i.beforeBuildLabels () i.buildLabels () i.afterBuildLabels () i.beforeFit () i.fit (), i. Depois de ajustar (), i.afterUpdate (), i.minSize}, afterUpdate: Ti, beforeSetDimensions: Ti, setDimensions: function () {var t = this; t.isHorizontal ()? (t.width = t.maxWidth, t .left = 0, = t.right t.width) :( t.height = t.maxHeight,t.top = 0, = t.bottom t.height) t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {largura: 0, altura: 0}}, afterSetDimensions: Ti, beforeBuildLabels: Ti, buildLabels: Ti, afterBuildLabels: Ti, beforeFit: Ti, fit: function () {var t, e = isto, n = e.options, i = e.minSize = { ?}, a = e.isHorizontal (); n.display (t = (V.isArray (n.text) n.text.length: 1) * V.options._parseFont (N) + 2 * n .lineHeight .padding, e.width = i.width = um e.maxWidth :? t = e.height i.height = um t: e.maxHeight): e.width = i.width = e.height = i. height = 0}, afterFit: Ti, isHorizontal: function () {var t = this.options.position; return "top" === t || "bottom" === t}, draw: function () {var t = this, e = t.ctx, n = t.options; if (n.display) {var i, a, r, o = V.options._parseFont (n), s = o.lineHeight, l = s /2+n.padding,u=0,d=t.top,h=t.left,c=t.bottom,f=t.right;e.fillStyle=V.valueOrDefault(n.fontColor,z.global .defaultFontColor) e.font = o.string, t.? IsHorizontal () (a = h + (fh) / 2, R = d + l, i = fh) :( a = "esquerda" === n.position H + L? Fl, R = d + (CD) /2,i=cd,u=Math.PI*("left"===n.position?-.5:.5)),e.save(),e.translate(a,r),e. rotate (u), e.textAlign = "center", e.textBaseline = "middle"; var g = n.text; if (V.isArray (g)) para (var p = 0, m = 0; m < g.length; ++ m) e.fillText (g [m], 0, p, i), p + = s; caso contrário, e.fillText (g, 0,0, i); e.restore ()}}} ); função Fi (t, e) {var n = new Ii ({ctx: t.ctx, opções: e, gráfico: t}); ge.configure (t, n, e), ge.addBox (t, n), t.titleBlock = n} var Li = {}, Oi = ki, Ri = Di, zi = {id: "title", _ elemento: Ii, beforeInit: function (t) {var e = t.options. title; e && Fi (t, e)}, beforeUpdate: function (t) {var e = t.options.title, n = t.titleBlock; e? (V.mergeIf (e, z.global.title), n? (ge.configure (t, n, e), n.options = e): Fi (t, e)): n && (ge.removeBox (t, n), exclua t.titleBlock)}}; for (var Ni em Li.filler = Oi, Li.legend = Ri, Li.title = zi, tn.helpers = V, function () {function t (t, e, n) {var i; return "string" == tipo de t? (i = parseInt (t, 10), - 1! = = t.indexOf ("%") && (i = i / 100 * e.parentNode [n])): i = t, i} função e (t) {return null! = t && "none"! == t } função n (n, i, a) {var r = document.defaultView, o = V._getParentNode (n), s = r.getComputedStyle (n) [i], l = r.getComputedStyle (o) [i] , u = e (s), d = e (l), h = Number.POSITIVE_INFINITY; return u || d? Math.min (u? t (s, n, a): h, d? t (l, o, a): h): "none"} V.where = function (t, e) {if (V.isArray (t) && Array.prototype.filter) retorna t.filter (e); var n = [] ; return V.each (t, (função (t) {e (t) && n.push (t)})), n}, V.findIndex = Array.prototype.findIndex? function (t, e, n) { return t.findIndex (e, n)}: function (t, e, n) {n = void 0 === n? t: n; para (var i = 0, a = comprimento t; i <a; ++ i) se (e.call (n, t [i], i, t)) retornar i; return-1}, V.findNextWhere = function (t, e, n) {V.isNullOrUndef (n) && (n = -1); for (var i = n + 1; i <comprimento t; i ++) {var a = t [i]; if (e (a)) retorna a}}, V.findPreviousWhere = função (t, e, n) {V.isNullOrUndef (n) && (n = comprimento t); for (var i = n-1; i> = 0; i -) {var a = t [i]; se (e (a)) retornar a}}, V.isNumber = function (t) {return! isNaN (parseFloat (t)) && isFinite (t)}, V.almostEquals = function (t, e , n) {return Math.abs (te) <n}, V.almostWhole = function (t, e) {var n = Math.round (t); return ne <= t && n + e> = t}, V. max = function (t) {return t.reduce ((function (t, e) {return isNaN (e)? t: Math.max (t, e)}), Number.NEGATIVE_INFINITY)}, V.min = function (t) {return t.reduce ((function (t, e) {return isNaN (e)? t: Math.min (t, e)}), Number.POSITIVE_INFINITY)}, V.sign = Math.sign? função (t) {retornar Math.sign (t)}: função (t) {retornar 0 === (t = + t) || isNaN (t)? t: t> 0? 1: -1}, V .toRadians = função (t) {retornar t * (Math.PI / 180)}, V.toDegrees = function (t) {return t * (180 / Math.PI)}, V._decimalPlaces = function (t) {if (V.isFinite (t)) {for (var e = 1, n = 0; Math .round (t * e) / e! == t;) e * = 10, n ++; retorno n}}, V.getAngleFromPoint = função (t, e) {var n = ex-tx, i = ey-ty , a = Math.sqrt (n * n + i * i), r = Math.atan2 (i, n); retorna r <-. 5 * Math.PI && (r + = 2 * Math.PI), {angle: r, distância: a}}, V.distanceBetweenPoints = function (t, e) {retorna Math.sqrt (Math.pow (ex-tx, 2) + Math.pow (ey-ty, 2))}, V. aliasPixel = função (t) {return t% 2 == 0? 0: 0,5}, V._alignPixel = função (t, e, n) {var i = t.currentDevicePixelRatio, a = n / 2; return Math. round ((ea) * i) / i + a}, V.splineCurve = function (t, e, n, i) {var a = t.skip? e: t, r = e, o = n.skip? e: N, s = Math.sqrt (Math.pow (rx-ax, 2) + Math.pow (ry-ay, 2)), l = Math.sqrt (Math.pow (ox-rx, 2) + Math.pow (oy-ry, 2)), u = s / (s + l), l = d / (s + l) = h i * (u = isNaN (u) 0? u), c = i *:; retorno {anterior (d = isNaN (d) 0 d?): {x: RX-H * (ox-ax) y: ry-H * (oy ay)}, seguinte: {x r.x + c * (ox-ax) y: r.y + c * (oy ay)}}} || Number.EPSILON V.EPSILON = 1e-14, V.splineCurveMonotone = função (t) {var e., n, i, a, r, O, s, L, L, d = (t || []) mapa ((função (t) {return {modelo t._model, DELTAK: 0, mK: 0}})), h = D.Length, porque (e = 0; e <h;!. ++ e) if ((i = d [e]) model.skip) {if (n = e> 0 ? d [e-1]: null, (a = e <h-1? d [e + 1]: null) &&! a.model.skip) {var c = a.model.xi.model.x; i.deltaK = 0 == c (a.model.yi.model.y) / c:!?! 0} n || n.model.skip i.mK = i.deltaK :! um || a. model.skip i.mK = n.deltaK: this.sign (n.deltaK) == this.sign (i.deltaK) i.mK = 0 = :? i.mK (n.deltaK + i.deltaK ) / 2} para (e = 0; e <h-1; ++ e) i = d [e], a = d [e + 1], i.model.skip || || a.model.skip (V.almostEquals (i.deltaK, 0, this.EPSILON) i.mK = a.mK = 0 :? (r = i.mK / i.deltaK, o = a.mK / i.deltaK, (l = Math.pow (r, 2) + Math.pow (O, 2)) <= 9 || (s = 3 / Math.sqrt (l), i.mK = r * s * i.deltaK, a.mK = o * S * i.deltaK))); para (e = 0; e <h; ++ e) (i = d [e]) model.skip || (N = e.> 0 d [e? -1]: zero, a = e <h-1 d [e + 1]: nulo,n &&! n.model.skip && (u = (i.model.xn.model.x) /3,i.model.controlPointPreviousX=i.model.xu,i.model.controlPointPreviousY=i.model.yu*i. mK), a &&! a.model.skip && (u = (a.model.xi.model.x) /3,i.model.controlPointNextX=i.model.x+u,i.model.controlPointNextY=i.model .y + u * i.mK))}, V.nextItem = function (t, e, n) {return n? e> = t.length-1? t [0]: t [e + 1]: e > = t.length-1? t [t.length-1]: t [e + 1]}, V.previousItem = function (t, e, n) {return n? e <= 0? t [t. comprimento-1]: t [e-1]: e <= 0? t [0]: t [e-1]}, V.niceNum = função (t, e) {var n = Math.floor (V. log 10 (t)), i = t / Math.pow (10, n); retorno (e I <1,5 1: i <3 2: i <7 5: 10: i <= 1 1 ????? i <= 2? 2: i <= 5? 5: 10) * Math.pow (10, n)}, V.requestAnimFrame = "undefined" == tipo de janela? function (t) {t ()}: window .requestAnimationFrame || || window.webkitRequestAnimationFrame window.mozRequestAnimationFrame || janela.oRequestAnimationFrame || window.msRequestAnimationFrame || função (t) {retornar window.setTimeout (t, 1e3 / 60)}, V.getRelativePosition = função (t, e) {var n, i, a = t.originalEvent || t , r = t.target || t.srcElement, o = r.getBoundingClientRect () s = a.touches ;? s && s.length> 0 (n = s [0] .clientX, i = s [0] .clientY ) :( n = a.clientX, i = a.clientY); var l = parseFloat (V.getStyle (r, "padding-left")), u = parseFloat (V.getStyle (r, "padding-top" )), d = parseFloat (V.getStyle (r, "padding-direito")), h = parseFloat (V.getStyle (r, "padding-bottom")), c = o.right-o.left-ld , f = o.bottom-o.top-uh; {retorno x: n = Math.round ((no.left-l) /c*r.width/e.currentDevicePixelRatio), y: i = Math.round ( (io.top-u) /f*r.height/e.currentDevicePixelRatio)}}, V.getConstraintWidth = function (t) {return n (t, "largura máxima", "clientWidth")}, V.getConstraintHeight = função (t) {retorna n (t, "max-height "" clientHeight ")} V._calculatePadding = function (t, e, n) {return (e = V.getStyle (t, e)) indexOf (." % ")> - 1 n *? parseInt (e, 10) / 100: parseInt (e, 10)}, V._getParentNode = função (t) {var e = t.parentNode; return e && "[objeto ShadowRoot]" === e.toString () && (e = e.host), e}, V.getMaximumWidth = function (t) {var e = V._getParentNode (t); se (! e) retornar t.clientWidth; var n = e.clientWidth, i = nV ._calculatePadding (e, "padding-left", n) -V._calculatePadding (e, "padding-right", n), a = V.getConstraintWidth (t); return isNaN (a)? i: Math.min ( i, a)}, V.getMaximumHeight = função (t) {var e = V._getParentNode (t); se (! e) retornar t.clientHeight; var n = e.clientHeight, i = nV._calculatePadding (e, "padding-top", n) -V._calculatePadding (e, "padding-bottom", n), a = V.getConstraintHeight (t); return isNaN (a)? i: Math.min (i, a)} , V.getStyle = função (t, e) {retorna t.currentStyle? t.currentStyle [e]: document.defaultView.getComputedStyle (t, null) .getPropertyValue (e)}, V.retinaScale = function (t, e) {var n = t.currentDevicePixelRatio = e || "indefinido"! = tipo de janela && window.devicePixelRatio || 1; if (1! == n) {var i = t.canvas, a = t.height, r = t.width; i.height = a * n, i.width = r * n, t.ctx.scale (n, n), i.style.height i.style.width || || (i.style.height = a + " px ", i.style.width = r +" px ")}}, V.fontString = função (t, e, n) {return e +" "+ t +" px "+ n}, V.longestText = function (t , e, n, i) {var a = (i = i || {}). data = i.data || {}, r = i.garbageCollect = i.garbageCollect || []; i.font! = = e && (a = i.data = {}, r = i.garbageCollect = [], i.font = e), t.font = e; var o, s, l, u, d, h = 0, c = n.length; para (o = 0; o <c o ++) (= nulo (u = n [O]) && 0 == V.isArray (u)!) se h = V.measureText (t , a, r, h, u); caso contrário, se (V.isArray (u)) for (s = 0, l = u.comprimento; s <l; s ++) null == (d = u [s]) || V.isArray (d) || (h = V.measureText (t, a, r, h, d)); var f = r.length / 2; se (f> n.length) {for (o = 0; o <f; o ++) exclua um [r [o]]; r.splice (0, f)} retorne h}, V.measureText = função (t, e, n, i, a) {var r = e [a]; retorna r || (r = e [a] = t.measureText (a) .width, n.push ( a)), r> i && (i = r), i}, V.numberOfLabelLines = function (t) {var e = 1; retorna V.each (t, (function (t) {V.isArray (t) &&t .length> e && (e = t.length)})), e}, V.color = k? function (t) {retorna a instância do CanvasGradient && (t = z.global.defaultColor), k (t)}: function (t) {return console.error ("Color.js não encontrado!"), t}, V.getHoverColor = function (t) {return t instância do CanvasPattern || t instância do CanvasGradient? t: V.color (t). saturado (0,5) .darken (0,1) .rgbString ()}} (), = tn._adapters em, tn.Animation = Z, = $ tn.animationService, tn.controllers = $ t, tn.DatasetController = nt , tn.defaults = z, tn.Element = X,tn.elements = _t, tn.Interaction = AE, tn.layouts = ge, tn.platform = Fe, tn.plugins = Le, tn.Scale = xn, tn.scaleService = Oe, tn.Ticks = rn, tn. dica = Ue, tn.helpers.each (ci, (função (T, e) {tn.scaleService.registerScaleType (S, T, t._defaults)})), Li) Li.hasOwnProperty (Ni) && tn.plugins. registre (Li [Ni]); tn.platform.initialize (); var Bi = tn; retorne "indefinido"! = tipo de janela && (window.Chart = tn), tn.Chart = tn, tn.Legend = Li.legend ._element, tn.Title = Li.title._element, tn.pluginService = tn.plugins, tn.PluginBase = tn.Element.extend ({}) = tn.canvasHelpers tn.helpers.canvas, tn.layoutService = tn .layouts, tn.LinearScaleBase = Sn, tn.helpers.each ([ "bar", "bolha", "doughnut", "linha", "Área polar", "radar", "dispersão"] (função (t) {tn [t] = função (e, n) {retorna novo tn (e, tn.helpers.merge (n || {}, {tipo: t.charAt (0))toLowerCase () + t.slice (1)}))}})), Bi}));